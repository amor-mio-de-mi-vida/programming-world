# 期中复习之动态规划（2）

## 过河卒 P1002

ps：这道题其实是一道数学题~

### 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/vg6k477j.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

### 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

### 输出格式

一个整数，表示所有的路径条数。

### 样例 #1

#### 样例输入 #1

```
6 6 3 3
```

#### 样例输出 #1

```
6
```

### 提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题

思路：

到其中某一个点的路径数 = 到他左边一格点的路径数 + 到他上面一格点的路径数

(那怎么处理马控制点呢？)

可以说是爬楼梯的那道题的二维版~

代码：

```c
#include <stdio.h>
long long array[25][25];
int check[25][25];

int dx[]={2,2,1,1,-1,-1,-2,-2,0};
int dy[]={-1,1,-2,2,-2,2,1,-1,0};

int main()
{
	int n,m;
	int i,j;
	int x,y;
	int n1,m1;
	
	scanf("%d%d%d%d",&n,&m,&n1,&m1);

	for(i=0;i<9;i++){
		x = n1 + 1 + dx[i];
		y = m1 + 1 + dy[i];
		if(x>=1&&x<=n+1&&y>=1&&y<=m+1)
			check[x][y]=1;
	}
	
	array[1][1]=1;
	for(i=1;i<=n+1;i++){
		for(j=1;j<=m+1;j++){
			if(i==1&&j==1) continue;
			if(check[i][j]==0){
				array[i][j]=array[i-1][j]+array[i][j-1];
			}
		}
	}
	
	printf("%lld",array[n+1][m+1]);
	return 0;
	
	
}
```

