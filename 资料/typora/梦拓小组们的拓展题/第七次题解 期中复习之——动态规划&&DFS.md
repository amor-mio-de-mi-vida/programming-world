# 期中复习之——动态规划&&DFS

## 求细胞数量 P1451

### 题目描述

一矩形阵列由数字 $0$ 到 $9$ 组成，数字 $1$ 到 $9$ 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。

### 输入格式

第一行两个整数代表矩阵大小 $n$ 和 $m$。

接下来 $n$ 行，每行一个长度为 $m$ 的只含字符 `0` 到 `9` 的字符串，代表这个 $n \times m$ 的矩阵。

### 输出格式

一行一个整数代表细胞个数。

### 样例 #1

#### 样例输入 #1

```
4 10
0234500067
1034560500
2045600671
0000000089
```

#### 样例输出 #1

```
4
```

### 提示

##### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n,m \le 100$。

![image-20221010174320149](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221010174320149.png)

## 代码：

```c
#include <stdio.h>

int a[105][105]={0};
int check[105][105]={0};
void dfs(int x,int y);
//这个函数的作用就是通过一个点出发，标记他和
//他周围所有的"细菌" 作为一个细菌坨
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
//这两个数组保存上下左右四个方向的数
int main()
{
	int n,m;
	int i,j;
	int cnt=0;
	scanf("%d%d",&n,&m);// 读取n行m列
	
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			scanf("%1d",&a[i][j]);  // 大家多去复习复习scanf的用法，期中考试
		}						    //很愿意考读入操作， %1d的意思是每次仅读入
	}							    //一位数字保存到a[i][j]中。
		
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			
			if(!check[i][j] && a[i][j]){
				dfs(i,j);
				cnt++;
				//细菌坨的个数++
			}
			
		}
	}
	
	printf("%d",cnt);
	
	return 0;
	
}

void dfs(int x,int y){
	int i;
	int nx,ny;
	check[x][y] = 1;
	
	for(i=0;i<4;i++){		//遍历上下左右四个方向的细菌
		nx = x + dx[i];
		ny = y + dy[i];
		
		if(a[nx][ny] && !check[nx][ny]){	//进入细菌坨的条件：这里有细菌
										 // 即a[nx][ny]!=0 并且他之前没有被标记过
            							  // 即check[nx][ny] = 0
            dfs(nx,ny);					   // 继续以a[nx][ny]为基准标记他上下左右的方块。
		}									
	}
	
	return;
}
```

注：DFS的本质是暴力遍历每一种情况，取选择符合要求的路径，实现的方式就是递归。大家好好理解一下递归，我之后还会找很多递归的题(这个还是比较难的)。



##滑雪 P1434

### 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
```
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24$－$17$－$16$－$1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。

### 输入格式

输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。

### 输出格式

输出区域中最长滑坡的长度。

### 样例 #1

#### 样例输入 #1

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

#### 样例输出 #1

```
25
```

### 提示

对于 $100\%$ 的数据，$1\leq R,C\leq 100$。



## 代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int a[110][110];
int f[110][110];
int check[105][105];
int max(int a,int b);
//这个函数用来求a，b的最大值
int dfs(int x,int y);、
//这个函数的作用是算出从(x,y)开始的最长滑雪路径
int R,C;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};

int main()
{
	int i,j;
	int ans=0;
	
	
	scanf("%d%d",&R,&C);
	//初始化处理
	for(i=0;i<=R+1;i++){	//将边界的高度设置为无限高这样就免去了判断是否超出地图限制
		for(j=0;j<=C+1;j++){
			a[i][j]=1e9;
		}
	}
	//读入每一个点的数据
	for(i=1;i<=R;i++){
		for(j=1;j<=C;j++){
			scanf("%d",&a[i][j]);
		}
	}
	
	for(i=1;i<=R;i++){
		for(j=1;j<=C;j++){
			ans = max(ans,dfs(i,j));
		}
	}
	//每一个点都跑一遍dfs，答案取最大的就是题目要求了
	
	printf("%d",ans);
	
	return 0;
}
int max(int a,int b){
	if(a > b)
		return a;
	return b;
}

int dfs(int x,int y){
	int i=0;
	int nx,ny;
	if(f[x][y])	return f[x][y];//一开始每个点的步数都应该为0，
							   //如果当前这个点已知其最大步数说明之前该点
							   //已经被计算过就不用再重复计算了
	f[x][y]=1;				   //既然这是一个从未走过的点那么现在来到该点至少都会使其步数为1
	for(i=0;i<4;i++){	//四个可行的方向
		nx = x + dx[i];
		ny = y + dy[i];
		if(a[nx][ny] < a[x][y]){
			f[x][y] = max(f[x][y],1+dfs(nx,ny));	//代码核心（状态转移方程）
		}
	}
	return f[x][y];						//返回值给上一个dfs调用
}
```

