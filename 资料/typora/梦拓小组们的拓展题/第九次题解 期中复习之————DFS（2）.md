# 期中复习之————DFS（2）

鉴于这个递归确实有点小难，我又给大家多找了几道题

## 高手去散步 P1294

### 题目背景

高手最近谈恋爱了。不过是单相思。“即使是单相思，也是完整的爱情”，高手从未放弃对它的追求。今天，这个阳光明媚的早晨，太阳从西边缓缓升起。于是它找到高手，希望在晨读开始之前和高手一起在鳌头山上一起散步。高手当然不会放弃这次梦寐以求的机会，他已经准备好了一切。

### 题目描述

鳌头山上有n个观景点，观景点两两之间有游步道共m条。高手的那个它，不喜欢太刺激的过程，因此那些没有路的观景点高手是不会选择去的。另外，她也不喜欢去同一个观景点一次以上。而高手想让他们在一起的路程最长（观景时它不会理高手），已知高手的穿梭机可以让他们在任意一个观景点出发，也在任意一个观景点结束。

### 输入格式

第一行，两个用空格隔开的整数n、m. 之后m行，为每条游步道的信息：两端观景点编号、长度。

### 输出格式

一个整数，表示他们最长相伴的路程。

### 样例 #1

#### 样例输入 #1

```
4 6
1 2 10
2 3 20
3 4 30
4 1 40
1 3 50
2 4 60
```

#### 样例输出 #1

```
150
```

### 提示

对于100%的数据:n≤20，m≤50，保证观景点两两之间不会有多条游步道连接.

## 代码

```c
#include  <stdio.h>

int array[25][55];	//保存顶点距离的矩阵 (邻接矩阵)
int check[25];		//记录顶点是否被标记的数组
void dfs(int x);	

int max(int a,int b);
//求最大值函数

int ans;//保存最后的结果
int n,m;//保存行数和列数
int sum;//保存每次路径和

int main()
{
	int i;
	int a,b,c;
	scanf("%d%d",&n,&m);
	
	for(i=1;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		array[a][b]=array[b][a]=c;	
	}
	
	for(i=1;i<=n;i++){
		sum = 0;
		dfs(i);			//遍历以i为起点的路径最大和
		check[i]=0;		//取消i的标记(回溯的过程)
	}
	
	printf("%d",ans);
	return 0;
	
}

int max(int a,int b)
{
	if(a>b)
		return a;
	return b;
}

void dfs(int x)
{
	int y;
	check[x]=1;		//到达了x点，标记已经访问过
	int flag=0;		//用于判断是否到达了终点(无路可走)
	
	for(y=1;y<=n;y++){
		if(array[x][y]!=0 && !check[y]){///如果满足有边且没有被访问过
			flag =1;			//没有"无路可走"
			sum+=array[x][y];	//加上(x,y)v边的权重
			dfs(y);				//以y为起点访问别的路径
			sum-=array[x][y];	//回溯——撤销掉(x,y)边。
			check[y]=0;			//撤销y的标记
		} 
	}
	if(flag==0){
		ans = max(ans,sum);		//如果到达了中点，更新ans的值(取最大的那个)
	}
	
	return;
}
```

