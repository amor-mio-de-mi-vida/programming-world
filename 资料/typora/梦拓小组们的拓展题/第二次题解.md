# 洛谷P1007

## 独木桥

### 题目背景

战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳 $1$ 个人通过。假如有 $2$ 个人相向而行在桥上相遇，那么他们 $2$ 个人将无法绕过对方，只能有 $1$ 个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。

### 题目描述

突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为 $L$，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为 $1$，但一个士兵某一时刻来到了坐标为 $0$ 或 $L+1$ 的位置，他就离开了独木桥。

每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。

由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。

### 输入格式

第一行共一个整数 $L$，表示独木桥的长度。桥上的坐标为 $1, 2, \cdots, L$。

第二行共一个整数 $N$，表示初始时留在桥上的士兵数目。

第三行共有 $N$ 个整数，分别表示每个士兵的初始坐标。

### 输出格式

共一行，输出 $2$ 个整数，分别表示部队撤离独木桥的最小时间和最大时间。$2$ 个整数由一个空格符分开。

### 样例 

#### 样例输入

```
4
2
1 3
```

#### 样例输出 

```
2 4
```

### 提示

对于 $100\%$ 的数据，满足初始时，没有两个士兵同在一个坐标，$1\le  L\le5\times 10^3$，$0\le N\le5\times10^3$，且数据保证 $N\le L$。

## 题解

emmm这个题主要是想明白就好了，关键点在于当两个人相遇时，下一秒各自回头并且向前走，但当你仔细画一画图操作一下会发现，可以看成两个士兵互相穿过去的情况。

那么最短的时间就是离中点最近的人向外走

最长时间就是离中点最远的人向中点走，并越过中点走到出口。

其实最多和最少的分割点就是L+1的中点，在中点左边的士兵只需都往左走即可达到最短时间时间为士兵的坐标a，往右走就是所需最大时间L+1-a. 而在中点右边的情况与左边处理方法相反，原理是一样的。

接着如果总最小时间应该是左边和右边士兵中时间最小中最大的（离中点最近），最大时间是左边和右边士兵中最大的（离中点最远）。

![image-20221004103541147](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004103541147.png)

```c
#include <stdio.h>
int a[10000];

int main()
{
	int L,N;
	int i;
	int len1,len2;
	int ans1 = 0;
	int ans2 = 0;
	scanf("%d%d",&L,&N);
	for(i=0;i<N;i++){
		scanf("%d",&a[i]);
		len1 = a[i] < L+1 - a[i] ? a[i] : L+1 - a[i];
		if(ans1 < len1)
			ans1 = len1;
		len2 = a[i] > L+1 - a[i] ? a[i] : L+1 - a[i];
		if(ans2 < len2)
			ans2 = len2;
	}
	printf("%d %d", ans1,ans2);
	return 0;
	
}
```

好吧本来看到这个题有那个“贪心算法”的标签的，结果好像也没有用。

# 洛谷P1031

## 均分纸牌

### 题目描述

有$N$堆纸牌，编号分别为 $1,2,…,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。

### 输入格式

第一行共一个整数 $N$，表示纸牌堆数。  
第二行共 $N$ 个整数 $A_1,A_2,\cdots,A_N$，表示每堆纸牌初始时的纸牌数。

### 输出格式

共一行，即所有堆均达到相等时的最少移动次数。

### 样例

#### 样例输入

```
4
9 8 17 6
```

#### 样例输出

```
3
```

### 提示

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。

![image-20221004113134314](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113134314.png)

```c
#include <stdio.h>
int array[105];

int main()
{
	int N;
	int i;
	int sum=0;
	int cnt=0;//移动的次数
	scanf("%d", &N);
	for(i=0;i<N;i++){
		scanf("%d", &array[i]);
		sum+=array[i];//求和
	}
	
	sum = sum / N;//求平均值
	for(i=0;i<N;i++){
		array[i]-=sum;
	}				//标准化一下，多于平均数的算正，少的算负，因为好算
	
	for(i=0;i<N-1;i++){//具体解释看图
		if(array[i]!=0){
		array[i+1]+=array[i];
		cnt++;
		}
	}
	
	printf("%d",cnt);
	return 0;
}
```

##  扩展：贪心算法

![image-20221004113420553](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113420553.png)

![image-20221004113536350](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113536350.png)

![image-20221004113624958](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113624958.png)

![image-20221004113643335](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113643335.png)

![image-20221004113700756](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113700756.png)

![image-20221004113721857](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113721857.png)

![image-20221004113739973](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113739973.png)

![image-20221004113758498](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20221004113758498.png)

参考网址：[(231条消息) 从零开始学贪心算法_houjingyi233的博客-CSDN博客_贪心算法](https://blog.csdn.net/qq_32400847/article/details/51336300?ops_request_misc=%7B%22request%5Fid%22%3A%22166484839016800182773833%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=166484839016800182773833&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-51336300-null-null.142^v51^new_blog_pos_by_title,201^v3^add_ask&utm_term=贪心算法&spm=1018.2226.3001.4187)