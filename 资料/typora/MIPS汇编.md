# 	MIPS汇编

## 入门简介

### MIPS汇编

#### **汇编语言**

与其说汇编语言是一种语言，不如说它是一种**助记符**——用一些易于理解的符号代表特定含义的机器码，用**标签**（Label）来替代地址。

相比于 C、Java 这些高级语言，汇编语言要低级的多，它和机器码几乎是一一对应的，一般用于**贴近于硬件**的编程，正如我们的计组实验。我们在这里学习汇编语言，一方面是为了让同学们通过学习汇编语言来理解计算机底层硬件的**运行过程**，另一方面是使用汇编语言来编写**测试程序**验证我们设计的 CPU 的正确性。

### 寄存器简介

#### **什么是寄存器？**

寄存器是 CPU 的组成部分之一，是一种**高速存储器**（甚至是 CPU 可以使用的最高速的一种存储器），可以用来暂存指令，数据，地址等。由于寄存器的成本较高，一般的 CPU 中只有数量很有限的寄存器可供使用。

在 MIPS 体系结构中，CPU 对数据的操作均是基于寄存器的。内存中的数据需要先使用读取（load）类指令保存到寄存器才可使用。操作完成的数据也不能直接保存到内存中，需要使用装载（store）类指令保存至内存中。

在我们实验中的 CPU 是 32 位 CPU，一次能处理的最大位数即为 32 位，绝大部分寄存器也均是 1 字大小的（即 4 字节，也就是 32 位）。

#### **MIPS 中的 32 个通用寄存器**

在一般的（至少是本课程所需要用的）MIPS 汇编程序中，比较常用的是 **32 个通用寄存器**。所谓通用寄存器，代表它没有明确规定的用途，程序员可以随意对他们赋值、取值，同时他们的值也可以直接参与到各种指令之中。然而，虽然冠有通用的头衔，程序员们还是会以一定的规则来使用它们，这是为了便于程序员之间的交流，同时也是为编译器等工具定下了一定的标准。

这 32 个通用寄存器有两种命名方式，一种是按序号命名 `$0~$31`（注意前面有个美元的符号），一种就是按功能命名，如下表：

![image-20220918171504438](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918171504438.png)

其中 usage 那一列可能暂时不好理解，没有关系，在之后的学习中会慢慢用到。特别地，对于 `$0` 和 `$1` 两个寄存器：

- `$0` 一般不能用于赋值，但这不代表你对它赋值就是错的。在实际中，你可以对 `$0` 进行赋值，但它的值会始终保持为 0。也就是说对 `$0` 赋值并不违反语法，但没有实际效果。
- `$1` 保留给汇编器，一般不使用此寄存器(使用该寄存器可能会导致难以发现的 bug，具体原因请在编写 MIPS 汇编时注意扩展指令是如何翻译成普通指令的)

#### **三个特殊寄存器**

- **PC（Program Counter）**：这个寄存器想必已经在理论课上讲解过了。它用于存储当前 CPU 正在执行的指令在内存中的地址。需要注意的是，这个寄存器的值不能用常规的指令进行取值和赋值，但这并不意味着不能做到，只是麻烦一些。**那么，怎样对其取值、赋值呢？**这可以作为一个思考的题目，在之后的学习中自行探索。（提示：跳转）
- **HI**：这个寄存器用于乘除法。它被用来存放每次乘法结果的**高 32 位**，也被用来存放除法结果的**余数**。
- **LO**：HI 的孪生兄弟。它被用来存放每次乘法结果的**低 32 位**，也被用来存放除法结果的**商**。

#### **CP0 寄存器**

当我们的 CPU 设计推进到比较深入的阶段时，我们就需要对**异常和中断**进行处理，届时我们就会使用到 CP0 寄存器。

CP0 是一个系统控制**协处理器**，而 CP0 寄存器则是该协处理器工作时需要用到的一些寄存器。在我们的实验中，只会用到其中的 4 个寄存器：SR、Cause、EPC 和 PRId。

这里先介绍一下这几个寄存器的职能，具体细节在 P7 时会详细讲解。

- **SR：**用于系统控制，决定是否允许异常和中断
- **Cause：**记录异常和中断的类型
- **EPC：**保存异常或中断发生时的 PC 值，也就是发送异常或中断时 CPU 正在执行的那条指令的地址。当处理完成之后，CPU 会根据这个地址返回到正常程序中继续往下执行。
- **PRId：**处理器 ID，用于实现个性的寄存器。

上面所述的那些寄存器是 MIPS 体系结构和我们的课程中常用的重要的寄存器，他们都是 32 位的。但寄存器的范围很广，上述的寄存器只是他们的一部分。除他们以外，还有许多寄存器被用于临时之用，或许都没有名字，而他们的真正应用，需要同学们在自己设计 CPU 时自行合理安排。

## MIPS指令集架构

### 认识MPIS汇编指令

#### 初识指令

在真正开始掌握 MIPS 汇编指令之前，我们需要先知道，什么是「指令」。指令，即是由处理器指令集架构（Instruction Set Architecture，**可以理解为计算机体系结构中对程序相关的部分所做的定义**）**定义的处理器的独立操作，这个操作一般是运算、存储、读取等。**一个指令在 CPU 中真正的存在形式是高低电平，也可以理解为由 01 序列组成的机器码。但因为机器码人类难以阅读和理解，所以指令一般由汇编语言来表示，也就是我们俗称的汇编指令。从这个角度上来说，汇编指令只是指令的一种表示形式而已，其实质是一样的。

一条指令的功能较为单一，一般不具有复杂的逻辑。例如「将某两个寄存器的值相加并存入另一个寄存器」，或者是「如果某个寄存器的值满足某个条件则跳转至某条指令」。不过，虽然这些指令很简单，但最终，我们可以用它们组合出丰富多彩、功能强大的程序。

那么，指令究竟长什么样呢？让我们来一起看一小段汇编程序：

```mips
.data
.text
.global main
main:
addi $t0,$0,100 # tag
ori $t1,$0,200
add $t2,$t1,$t2
sub $t3,$t2,$t1
lui $t4,233
ori $v0,1
ori $a0,2333
mthi $t1
ori $a0,2333
mthi $t1
syscall
nop
loop:
j loop
nop
```

其中tag标记的 `addi $t0, $0, 100` 就是一条指令，它的含义为“将 `$0` 寄存器的值加上 100，并将结果存入 `$t0` 寄存器”。

需要注意的是，虽然其主要由指令构成，但汇编语言并非全部由指令组成。上面的代码中，第 5-14、16-17 行为严格意义上的指令，**其余有标签、伪指令等。**相信看了上面一段代码样例，你已经找出了指令的规律，下面我们就来详细地进行解读。

#### **指令的格式**

在 MIPS 汇编语言中，指令一般由一个指令名作为开头，后跟该指令的操作数，中间由空格或逗号隔开。指令的操作数的个数一般为 0-3 个，每一个指令都有其固定操作数个数。一般来说，指令的格式如下：

*指令名* *操作数 1*, *操作数 2*, *操作数 3*

不过，也有如下的指令格式，一般用于存取类指令：

*指令名* *操作数 1*, *操作数 3(操作数 2)*

所谓操作数，即指令操作所作用的实体，可以是寄存器、立即数或标签，每个指令都有其固定的对操作数形式的要求。而标签最终会由汇编器转换为立即数。所谓立即数，即在指令中设定好的常数，可以直接参与运算，一般长度为 16 位二进制。而标签，用于使程序更简单清晰。标签用于表示一个地址，以供指令来引用。一般用于表示一个数据存取的地址（类似于数组名）、或者一个程序跳转的地址（类似于函数名，或者 C 语言中 `goto` 的跳转目标）。在 MIPS 汇编中（以及其他大部分汇编语言中），标签用如下的方式写出：

**`name:`**

其中的「name」代表这个标签的名称，可以自行取名。

常见的指令格式样例：

```mips
add $s0,$a0,$a1
addi $s0,$a0,12
mult $s1,$s2
beq $a1,$a2,-2
blez $s1,-2
jr $ra
j 0x00003014
```

当然，前面说过，可以使用标签来代替某个地址，因此也可以以如下方式书写：

```
beq $a1,$a2,loop
j loop
```

这里的 `loop` 就是一个标签，**他所代表的是一段代码的起始地址**。在进行汇编时，汇编器会自动把标签转换成我们所需要的立即数，**这样就不用我们自己去计算这些地址偏移量，简化了编程难度**。

**注意：在 MARS 中，跳转指令只能使用标签来进行跳转，不能使用立即数！**

由此可以看出，在 MIPS 汇编语言中，操作数的形式并非绝对严格固定的，而是具有一定的灵活度。虽然在 MIPS 标准指令集中，一条机器码指令的格式是固定的，但汇编器可以将多种形式的汇编指令转换为同样意思的机器码指令。因此，许多指令有比标准写法简单的写法。这部分内容会在后面进行讲解（详见「**扩展指令**」），或者也可以自行查阅 MARS 的帮助文档。

为了更好的理解汇编指令，下一小节将详细讲解 MIPS 机器码指令，这一汇编指令转换后的形式。

**PS**：在本教程中，没有特殊说明的情况下都不需要考虑到延迟槽的存在。

### 机器码指令

#### 认识机器码

大家都知道，计算机只能理解二进制形式的数据。而我们前面所说的汇编语言，最终就会转化为机器语言——也就是机器码指令， CPU 可以直接识别这种机器语言，从而去完成相应的操作。在我们学习的 MIPS 汇编中，所有的指令长度均为 32 位，即 4 字节，或者说 1 字。同时，从硬件的角度来讲，每条指令的执行周期大多为 1 个 CPU 周期，这在深入学习之后可以更好地理解，这里只是阐述一个概念。**因此机器码就是 CPU 最基本的一种操作，也是原子操作，不可被打断。**

所有指令长度均相同，这是精简指令集（RISC，Reduced Instruction Set Computing）的特征，这种指令集包括 MIPS 和手机中常用的 ARM 等；与之相对的是复杂指令集（CISC，Complex Instruction Set Computing），包括 PC 中常用的 x86 架构，这种指令集的特点是指令数目多、指令长度并不完全相同。

一段汇编语言可以转换为一段机器码，例如下面这段汇编指令：

```
.data
.text
.global main
main:
addi $t0,$0,100
ori $t1,$0,200
add $t2,$t1,$t2
sub $t3,$t2,$t1
lui $t4,233
ori $v0,1
ori $a0,2333
mthi $t1
syscall
nop
loop:
j loop
nop
```

其转换后的结果为（16 进制）：

```
20080064
340900_c8
012_a5020
01495822
3_c0c00e9
34420001
3484091_d
01200011
0000000_c
00000000
08000_c0a
00000000
```

#### **机器码的指令格式**

32 位的机器码需要一定的格式才能被理解。一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。

- **R 型指令**

R 型指令的操作数最多，一般用于运算指令。例如 `add`、`sub`、`sll` 等。其格式如下（左侧为高位，右侧为低位）：

![image-20220918192216723](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918192216723.png)

- **I 型指令**

I 型指令的特点是有 **16 位的立即数**（偏移也是一样的道理）。因此，I 型指令一般用于 `addi`、`subi`、`ori` 等与立即数相运算的指令（**这里需要注意：在写汇编语言的时候，需要使用负号来标记负数，而不要和机器码一样认为首位的 1 就代表负数**），或 `beq`、`bgtz` 等比较跳转指令，因为它们要让两个寄存器的值相比并让 PC 偏移 offset 这么多，刚好利用了全部的字段。还有存取指令，例如 `sw`、`lw`，它们在使用时需要对地址指定一个偏移值，也会用到立即数字段。

![image-20220918192244249](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918192244249.png)

- **J 型指令**

J 型指令很少，常见的为 `j` 和 `jal`。他们需要直接跳转至某个地址，而非利用当前的 PC 值加上偏移量计算出新的地址，因此需要的位数较多。

![image-20220918192305359](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918192305359.png)

需要注意的是，严格来说，并非所有的指令都严格遵守上面三种格式，有的如 `eret`、`syscall` 指令一样没有操作数；有的如 `jalr` 指令一样某些字段被固定为某个值。不过，就大部分指令而言，都可按上面三种格式进行解释，某些字段被固定也可以按照格式来识别为 R、I、J 中的一种，因此这三种格式要着重理解。

**解读：**

- **op**：也称 opcode、操作码，用于标识指令的功能。CPU 需要通过这个字段来识别这是一条什么指令。不过，由于 op 只有 6 位，不足以表示所有的 MIPS 指令，因此在 R 型指令中，有 func 字段来辅助它的功能。

- **func**: 用于辅助 op 来识别指令。

- **s**、**rt**、**rd**： 通用寄存器的代号，并不特指某一寄存器。范围是`$0~$31`，用机器码表示就是 00000~11111。

- **shamt**：移位值，用于移位指令。

- **offset**：地址偏移量。

- **immediate**：立即数。

- **address**：跳转目标地址，用于跳转指令。

#### **结合手册读懂指令**

下面我们结合文档《MIPS-C 指令集》来讲解如何读懂一条机器码指令的功能与格式。下表为 `add` 指令的指令详解：

![image-20220918201934948](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918201934948.png)

- **编码**：二进制指令各字段的值和功能。这里可以看出，`add` 指令的 opcode 为 000000；其后跟随着 rs、rt、rd 三个指示寄存器的字段；之后为全 0 的 shamt 字段，最后的 func 字段值为 100000。
- **格式**：汇编指令的书写格式。其中的 rd、rs 和 rt 在真正编写时要替换为具体的寄存器。
- **描述**：指令的功能。GPR 表示寄存器堆，在此和中括号括起来的寄存器编号结合起来可以理解为某个寄存器。例如 GPR[rd] 表示编号为 rd 的寄存器。**`add` 指令的描述表示该指令的功能为将编号为 rs 和 rt 的寄存器的值相加，存入编号为 rd 的寄存器中。**
- **操作**：指令的具体执行过程及细节。 GPR[rs]$_{31}$∣∣GPR[rs] 表示将 rs 号寄存器的 bit31 和 rs 号寄存器原本的值进行拼接，组合成一个 33 位的数值。进一步地，temp←(GPR[rs]$_{31}$∣∣GPR[rs])+(GPR[rt]$_{31}$∣∣GPR[rt]) 表示将这两个 33 位的数值相加，存入一个临时变量 temp 中。**接着，判断这个临时变量的 bit32 和 bit31 进行比较，若不相等，则说明出现了溢出，那么就会引发整数溢出异常**（关于**异常**的知识会在以后学到）；如果没有发生溢出，则会将 temp 的低 32 位存入 rd 号寄存器中，作为最终的结果。
- **示例**：汇编指令书写样例。这里的 rs、rt 和 rd 已经替换为了具体的寄存器。
- **其他**：补充说明。这里提到如果不考虑溢出，则 `add` 与另一个指令：`addu` 等价，这便是指出了 `add` 的特性：**`add` 会检验计算的结果是否会溢出。**在一些C语言编译器中，加法的计算并不会引发异常。例如计算 2000000000+2000000000，得到的结果 -2094967296，说明计算出现了溢出，**但并未引发异常。这说明该编译器使用的是 `addu`。**

下图更加直观地表示了汇编指令转变为机器码指令的过程：

![image-20220918202659172](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918202659172.png)

事实上在 CPU 中，机器码还要按照同样的格式进行解码，并使 CPU 执行相应的功能。相关的知识会在今后学到。

上面的 `add` 指令中，所有的操作数形式均为寄存器，那么当操作数为标签时会怎样呢？事实上，汇编器会将标签翻译为一个立即数，再转化为机器码，下面以另一个指令：`beq` 为例子再进行一次详解。

![image-20220918202735984](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918202735984.png)

其所在的程序如下：

```
.text
label:
add $s1,$s2,$s3
beq $0,$s1,label
nop
```

**操作详解：**sign_extend() 代表符号扩展至 32 位，而符号扩展是与非符号扩展相对的，其扩展结果的正负会与原数相同，一般用于有符号数。其符号扩展的方法是在数字之前补若干个 0 或者 1 。这个取决于需要被符号扩展的数原本的正负性。如果原来的数为负数，那么符号扩展将在其前面增加若干个 1；如果原来的数为非负数，那么符号扩展将在前面增加若干个 0。具体增加 0 或者 1 的多少，根据具体的语境而定。offset∣∣$0^2$ 代表 offset 后面拼接 2 位的 0。例如 offset 为 1010，则拼接后的结果为 101000。

可以看到，offset 是一个数值，而 label 是一个标签，因此需要将 label 转化具体的数值。根据代码，`beq` 跳转之后的指令应为第3行：`add $s1, $s2, $s3`。这一条指令是 `beq` 的上一条指令，也就是说这两条指令的地址差 4。而根据手册，`beq` 跳转的结果为 PC+4+sign_extend(offset∣∣$0^2$)，也就是说 4+sign_extend(offset∣∣$0^2$)=−4。可以计算出，offset 为 0xfffe（注意这是一个 16 位的负数）。因此，最终 `beq $0, $s1,label` 的转化结果为 0x1011fffe。

除了上述的运算指令和跳转指令之外，MIPS 汇编中常用的指令还有存取指令，其中存、取的指令结构基本相同。下面以最基本的 `lw` 指令为例进行解读。

![image-20220918204816953](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220918204816953.png)

- **编码：**`lw` 是条 I 型指令，op=100011，base 字段其实就是一般I型指令格式中的 rs 寄存器字段。
- **格式：**存取指令的格式与一般 I 型指令不同：要把基地址 base 用括号括起来，外面是偏移量 offset。
- **操作：**首先将偏移量 offset **符号扩展**为 32 位后与 base 寄存器中的值相加，求出具体的内存地址。然后将该地址中数据提取出来赋给 rt 寄存器。这里的 memory[Addr] 指的是内存中**以 Addr 为首地址的 4 字节内存中存储的数据。**

- **约束：**对于存取指令，最终计算出来的地址 Addr 一般都是有强制约束的，比如 `lw` 指令的 Addr 就必须是 **4 的倍数**，因为 1 个字 = 4 个字节；`lh`（取半字）指令的 Addr 就必须是 **2 的倍数**，因为 1 个半字 = 2 个字节。这样做可以防止你对内存数据随意进行操作。

### 扩展指令和伪指令

为了方便编程，MIPS 汇编在标准指令的基础上又提供了许许多多的扩展指令，其中就包括前面提到过的对基本指令的转写（例如用标签代替立即数）。此外还有对基本指令的操作数的略写和使用基本指令组合出新的指令。这类**扩展指令**称为「Pseudo Instructions」。

虽然使用标签、基本指令和扩展指令已经可以写出汇编程序，但其灵活性仍有限制。例如，仅用标签和指令无法初始化变量（数据段中的数据）；无法区分代码属于普通代码或异常处理代码。因此，汇编器提供了**伪指令**（Directives）来让我们指导汇编器的工作。有了伪指令，我们可以**声明全局标签、声明宏、设置异常数据段和代码段**等等。

#### **扩展指令（PSEUDO INSTRUCTIONS）**

学过机器码之后，我们就可以将一条机器码还原为一条汇编指令，例如将 0x08000c0a 还原为 `j 0xc0a`。而 `j 0xc0a` 这种形式，我们可以将其称之为**标准指令**，或者叫**基本指令。**也就是说它的每个操作数都和机器码中的相应字段完美对应。然而，完全使用基本指令会大大降低程序的易读性和灵活性，因此便诞生了扩展指令。

学过机器码之后，我们就可以将一条机器码还原为一条汇编指令，例如将 0x08000c0a 还原为 `j 0xc0a`。而 `j 0xc0a` 这种形式，我们可以将其称之为**标准指令**，或者叫**基本指令。**也就是说它的每个操作数都和机器码中的相应字段完美对应。然而，完全使用基本指令会大大降低程序的易读性和灵活性，因此便诞生了扩展指令。

最常用到的一条扩展指令是li指令，它用来为某个寄存器赋值，比如 `li $a0,100` 就是将 100 赋给 `$a0` 寄存器。汇编器在翻译这条扩展指令时会根据需要，将它翻译成不同的基本指令或基本指令的组合。如下，第一条 `li` 指令后面的**立即数不多于 16 位，因此只被翻译成了一条 `addiu`**；第二条 `li` 指令后面的**立即数多于 16 位，因此被翻译成了 lui+ori 的组合**。

![image-20220919163547645](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919163547645.png)

另一条常用的扩展指令是 `la` 指令，这条指令与 `li` 指令非常类似，都是为寄存器赋值，只不过是使用标签来为寄存器赋值。经过了前面的学习，大家应该已经知道标签本质上对应一个 32 位地址，但 `li` 指令并不能直接使用标签来为寄存器赋值，必须要使用 `la`。比如 `la $t0, fibs` 这条指令就是把 fibs 这个标签的地址存入`$t0` 中。

![image-20220919163619896](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919163619896.png)

上面的例子就是利用现有基础指令组合出新的扩展指令。当然，我们也可以对现有指令进行简化或转写，例如前面提到过的 `j 0xc0a`，我们可以将其立即数改为一个标签，这样汇编器会在进行汇编时，会将标签所代表的立即数计算出来，形成基本指令的形式，例如下图：

![image-20220919163657128](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919163657128.png)

想要了解更多的扩展指令，可以查看 Mars 的 Help 文档中 Extended (pseudo) Instructions 一栏。

#### **伪指令（DIRECTIVES）**

伪指令（Directives）是用来指导汇编器如何处理程序的语句，有点类似于其他语言中的预处理命令。伪指令不是指令，它并不会被编译为机器码，但他却能影响其他指令的汇编结果。常用的伪指令有以下几个：

- **.data：**用于预先存储数据的伪指令的开始标志。
- **.text：**程序代码指令开始的标志。
- **.word：**以字为单位存储数据。
- **.asciiz：**以字节为单位存储字符串。
- **.space：**申请若干个字节的未初始化的内存空间。

这些指令的**详细介绍请参考第 4 节(MIPS 汇编程序解析)第 2 单元(变量的声明与分配)**。想要了解更多的伪指令可以查看 Mars 的 Help 文档中 Directives 一栏。

**注：Mars 的 Help 文档写得比较简略，例如它没有指出 `.data` 和 `.text` 伪指令后面可以跟着参数。因此优先以教程中的说法为准（也就是说你要去看看[汇编语言与 MARS：MIPS 汇编程序解析 / 变量声明与定义]）。**

------------------------------------

## MARS的获取与使用

### MARS简介

**MARS 在 CPU 设计时的作用**

在第二章我们已经提到了，测试程序能够很好的检测我们 CPU 程序的正确性。而 MARS 就是负责运行和调试测试程序，导出 CPU 需要的机器码，并向我们展示正确的运行结果。

### 界面介绍：

![image-20220919171410586](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919171410586.png)

![image-20220919171426999](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919171426999.png)

#### **菜单工具栏**

此处用于程序自身的基本操作及我们编写的汇编程序的运行、调试。

最上面一排为菜单栏，如图 3。其中，「File」用于开启新文件、打开旧文件、保存、另存为、关闭和导出程序等功能。「Edit」用于撤销、重做、剪切、复制、粘贴和查找替换。这两部分和大部分文本编辑软件是相同的。

![image-20220919171229863](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919171229863.png)

- 「Run」用于编译、运行和调试程序，如果用过其他 IDE 则对此部分会很熟悉。
- 「Setting」用于进行各种设定各种配置，例如代码编辑器的显示效果、高亮、是否显示某些窗口、程序如何编译等。
- 「Tools」中包含了许多调试工具，它们在后面会被讲到。
- 「Help」中，MARS 官方给出了十分详细的教程，包括 MIPS 汇编语言以及 MARS 自身，甚至还有十分有趣的“指令集之歌（Instruction Set Song）”，是十分有用的自学材料。不过，其中的知识我们并不要求完全掌握，更多的情况下是将其当做一个参考文档来使用。

#### **编辑器**

正如大部分 IDE，MARS 也有一个用于书写代码的编辑器。我们的程序即写入这一区域。

在「Settings」→「Editor」中可以设置编辑器的字体类型、字体大小和语法高亮等。

在编辑器的下方有一个复选框，可以选择是否显示行号。

#### **信息区**

屏幕的下方就是信息区，它有两个选项卡：Mars Message 和 Run I/O。Run I/O 用于显示程序运行时的命令行输出，或者你也可以在这里对程序进行输入。Mars Message 选项卡用于显示其他信息，例如编译或运行时错误，以及其他一些有用的信息。当它显示编译错误时，你可以点击相应的信息来选中编辑器中对应的代码。

#### **寄存器区**

MIPS 寄存器在所有时候都会显示，即使是你没有在运行程序的时候。当你编写你的程序的时候，你可以参考这一区域来使用各个编辑器的名称，或者知道他们的常用用法（将鼠标悬停在上面就可以看到）。这里有三个选项卡：「Registers」（32 个通用寄存器，加上 HI、LO 和 PC 寄存器）、 「Coproc 1」（浮点数寄存器）、「Coproc 0」（一部分 CP0 寄存器，和中断、异常有关）。

#### **运行界面**

当你点选「切换编辑与运行选项卡」中的「Execute」后，或者当你的程序编译成功后，会切换至运行界面。如下图所示：

![image-20220919171535834](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919171535834.png)

当程序编译成功之后，寄存器会被初始化。运行窗口分为两部分：代码段（Text Segment）窗口和数据段（Data Segment）窗口。事实上还有第三个窗口：标签窗口（Labels），这需要我们选择「Settings」→「Show Labels Window」来显示。

数据段下方的左右箭头按钮用于翻页，下拉选单用于直接定位至某些关键位置。右侧的两个复选框用于选择以十进制还是十六进制表示内存的地址和值。

#### **常用操作总结**

- 新建文件(Ctrl+N): 菜单栏 File -> New

- 打开文件(Ctrl+O): 菜单栏 File -> Open

- 保存文件(Ctrl+S): 菜单栏 File -> Save

- 延迟槽: 菜单栏 Settings -> Delayed branching

  P5 后会使用，在学习延迟槽的具体原理前请勿勾选

- 初始地址设置：菜单栏 Settings -> Memory Configuration

  为了适应自动评测的需要，请务必将初始地址设置为下图所示状态:

![image-20220919171656198](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220919171656198.png)

- 官方帮助文档(F1): 菜单栏 Help -> Help

- MIPS->Basic instructions: 基本指令的格式以及简介

- MIPS->Extended (pseudo) instructions: 扩展指令的格式以及简介

- MIPS->Directives: 伪指令的格式以及简介

- MIPS->Syscalls: 系统调用的使用方法

- MARS->Command: 命令行操作规范(会在 P7 中使用)

### 编写、运行与调试

#### **延迟槽**

延迟槽是流水线 CPU 的重要知识点，并不在本讲的范围内，所以这里只会讲到 MARS 中延迟槽的设置与使用。

##### **设置延迟槽**

延迟槽是个可选设置，需要打开才能有效。打开方式为：「Settings」→「Delayed branching」，打上勾即为打开延迟槽。

##### **在打开延迟槽状态下运行程序**

当打开延迟槽运行程序时，在执行跳转指令后，程序不会立刻跳转，而是先执行完跳转指令的下一条指令，再进行跳转。这个所谓的跳转指令的下一条指令即为延迟槽，在运行时，其在代码段窗口中的高亮不是普通的黄色，而是绿色，如下图:

![image-20220922124212416](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922124212416.png)

#### **设置断点**

和许多其他的 IDE 一样，MARS 可以很方便地设置断点来进行调试。当程序运行到断点后会停下，等待我们的指示来进一步执行，此时便可查看程序的运行情况是否与预想相同。

当我们设置好断点后，点击运行按钮，程序会运行至下个断点处停止。

设置断点的方法很简单。编译完程序，跳转至程序运行界面后，在代码段窗口的左侧的一列（Bkpt）复选框即用来设置断点。在你希望停下的行的响应的复选框上点上勾，即为该行设置上了断点，如下图：

![image-20220922124417707](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922124417707.png)

#### **查看和修改数据**

为了便于调试和设置初值，我们可以选中某个寄存器或内存中的某个地址，左键双击就可以手动设置它的值，如下图：

![image-20220922124451493](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922124451493.png)

![image-20220922124512832](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922124512832.png)

### 代码与数据的导出

## **使用命令行操作**

### **命令行操作的功能**

上文所述的导出功能，只能对 .text(0x00003000-0x00003024) 和 .data(0x00000000-0x00000ffc) 这两部分内存进行导出。而在我们的实验中，还需对其他部分进行导出，例如异常处理程序，位于 .ktext(0x00004180-0x00004ffc)。

为了解决这个问题，MARS 提供了一个解决方案——命令行操作。使用命令行可以让你自己设定你所需要的导出内容。

### **官方使用指南**

MARS 提供了详细的文档来指导如何使用命令行。

1. 打开 MARS，点击工具栏右侧的 Help 
2. 按下图圈注的选项来选择即可看到命令行的官方使用方法

![image-20220922125213588](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922125213588.png)

### **使用样例**

导出中断处理程序，命令如下：

```
java -jar E:\Mars4_5.jar a db mc CompactDataAtZero dump 0x00004180-0x00004ffc HexText E:\code_handler.txt E:\source.txt
```

解析：

- `E:\Mars4_5.jar` 是 MARS 的文件路径

- `a db mc CompactDataAtZero dump` 这些参数的功能请自行查阅帮助文档

- `0x00004180-0x00004ffc` 是需要导出的地址范围

- `HexText` 表示导出的是 16 进制码

- `E:\code_handler.txt` 是 16 进制码输出文件路径

- `E:\source.txt` 是源文件路径

同学们请根据自己文件路径和需要将上述部分根据自己的情况进行更改，如果想进一步了解 Mars 的命令行操作，请参考 MARS 官方文档中 MARS -> Command 部分。如果同学们有兴趣可以尝试编写 bat 脚本文件，免去每次导出都要敲一串命令行指令的痛苦，这部分留作自学内容，请大家自行上网搜集资料进行学习。

## MIPS汇编程序解析

### 第一个汇编程序

现在，我们通过几个简单的汇编程序，理解汇编语言的形式和各个指令的用途。同学们可以把这些代码复制到自己的 MARS 编辑器中，并在自己的电脑上运行一遍，注意 MARS 调试功能的使用，使得同学们可以更清楚地看到寄存器中数值的变化，明白各个指令的意义。有关循环的一些内容，在后文中会有详细的解释。

下面以一个经典的题目为例，编写我们的第一个汇编程序。

题目内容：输出 ”Hello World“

**文本代码**：

```
.data
str: .asciiz    "Hello World"

.text
la  $a0, str
li  $v0, 4
syscall

li  $v0, 10
syscall             
```

这是最简单的一个 MIPS 汇编程序，同学们可以把这段代码复制到 MARS 中，在运行之前确保（Mars->Settings->Memory Configuration）为 Compact,Data at Address 0。这个选项，代表数据（.data）段的地址是从 0x0 开始，程序（.text）段的地址是从 0x3000 开始。

下面我们一行一行地分析这段代码。

第 1 行 `.data`，代表**变量的声明和分配**从这里开始

第 2 行 `str: .asciiz “Hello World”`，代表**分配了一定的内存空间**，用来存储这个字符串，字符串最后有一个 ’\0’，**str 是这个字符串的标签 (label)**

第 4 行的 `.text` 代表**程序从这里开始**

第 5 行的 `la`，是一个扩展指令，在按 F3 快捷键之后进入 Execute 页面，可以看到这一个指令被转换成了 `addi $4, $0, 0`；同理，第 6 行和第 8 行的 `li`，也是一个扩展指令，这一个指令被转换成了 `addiu $2, $0, 4` 和 `addiu $2, $0, 10`

第 7 行和第 9 行的 `syscall`，会根据当前的 `$v0` 寄存器的值，进行相应的操作，比如执行第 7 行 `syscall` 的时候，`$v0=4`，此时就会输出 `$a0` 寄存器指向的字符串，执行第 10 行 `syscall` 的时候，`$v0=10`，此时程序结束运行。有关 `syscall` 的说明，可以按快捷键 F1，在 MIPS -> Syscalls 页面中查到相应的用法。

这个 MIPS 汇编程序在运行的时候，先把 str 的地址 (0x0) 赋值给 `$a0`，然后令 `$v0=4`，执行`syscall`，输出 `$a0` 寄存器指向的字符串 ”Hello World”，直到遇到 ’\0’ 为止，最后令 `$v0=10`，执行 `syscall`，结束程序。

汇编语言与我们之前所学习的 C 语言还是有很大的区别，由于汇编语言的主体代码中并没有变量名、函数名、各种运算符号和语句块。**我们仅能通过有限的 32 个寄存器以及众多的汇编指令和标签来实现我们之前所学的 C 语言所能够实现的功能。**实际上 C 语言代码在经过编译后也会转换成汇编程序代码再进一步翻译成机器码，有兴趣的同学可以自行搜索相关资料进行学习，将来在操作系统和编译这两门课程中你们还将继续与这些汇编程序打交道。

如果认真阅读了上面的代码，想必已经体会到了汇编指令在可读性方面的巨大缺陷，所以请务必**为自己编写的汇编程序代码加上注释**，防止代码写完之后自己都看不懂。

### 一个简单循环的例子

下面以一个简单题目为例，说明在 MIPS 中如何使用循环。

题目内容：输入一个数 n*n*，输出 1+2+3+...+n1+2+3+...+*n*（保证 n*n* 和输出结果都在 int 的范围之内）

**文本代码**：

```
.text
li  $v0,5
syscall                 # 输入一个整数，输入的数存到 $v0 中
move $s0, $v0           # 赋值，$s0 = $v0
li  $s1, 0              # $s1 用于存储累加的值，$s1 = 0
li  $t0, 1              # $t0 是循环变量

loop:
bgt $t0, $s0, loop_end  # 这里用了一个扩展指令 bgt,当 $t0 > $s0 的时候跳转到 loop_end
add $s1, $s1, $t0       # $s1 = $s1 + $t0
addi $t0, $t0, 1        # $t0 = $t0 + 1
j   loop                # 无条件跳转到 loop 标签

loop_end:
move $a0, $s1           # 赋值，$a0 = $s1
li  $v0, 1              # $v0 = 1，在 syscall 中会输出 $a0 的值
syscall         
li  $v0,10              # $v0 = 10
syscall                 # 结束程序          
```

在运行之前确保（Mars -> Settings -> Delayed branching）前面不要打钩，即不考虑延迟槽，遇到跳转指令立刻跳转，不执行跳转指令之后的指令。（在 MIPS 教程和 P2 部分，如果不对延迟槽加以说明，我们都不用考虑延迟槽）

相比于”第一个汇编程序“小节中的输出 ”Hello world“ 的程序，这里多了 `syscall` 输入和输出整数的用法，以及 `move`、`bgt` 扩展指令，在 Execute 页面中对照 Basic 列和 Source 列的不同，就可以明白那条扩展指令是什么意思。利用这些扩展指令，可以简化我们编写汇编代码的工作量，并使得我们的汇编代码更加清晰。

![image-20220922134401677](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922134401677.png)

### 在MIPS中使用数组

下面以一个简单题目为例，说明在 MIPS 中如何使用数组。

题目内容：输入一个整数 n（2≤*n*≤10），接下来 n 行，每行一个整数（在 int 范围内），在输出的时候先输出 `The numbers are:`，然后把这 n 个整数按照输入顺序输出，两个数字中间一个空格，行末可以有空格。

**样例输入**：

> 4
>
> 2
>
> 3
>
> 1
>
> 4

**样例输出**：

> The numbers are: 2 3 1 4

**文本代码**：

```
.data
array: .space 40           # 存储这些数需要用到数组，数组需要使用 10 * 4 = 40 字节
                           # 一个 int 整数需要占用 4 个字节，需要存储 10 个 int 整数
                           # 因此，array[0] 的地址为 0x00，array[1] 的地址为 0x04
                           # array[2] 的地址为 0x08，以此类推。

str:   .asciiz "The numbers are:\n"
space: .asciiz " "

.text
li $v0,5
syscall                    # 输入一个整数
move $s0, $v0              # $s0 is n
li $t0, 0                  # $t0 循环变量

loop_in:
beq $t0, $s0, loop_in_end  # $t0 == $s0 的时候跳出循环
li $v0, 5
syscall                    # 输入一个整数
sll $t1, $t0, 2            # $t1 = $t0 << 2，即 $t1 = $t0 * 4
sw $v0, array($t1)         # 把输入的数存入地址为 array + $t1 的内存中
addi $t0, $t0, 1           # $t0 = $t0 + 1
j loop_in                  # 跳转到 loop_in

loop_in_end:
la $a0, str
li $v0, 4
syscall                    # 输出提示信息
li $t0, 0
loop_out:
beq $t0, $s0, loop_out_end
sll $t1, $t0, 2            # $t1 = $t0 << 2，即 $t1 = $t0 * 4
lw $a0, array($t1)         # 把内存中地址为 array + $t1 的数取出到 $a0 中
li $v0, 1
syscall                    # 输出 $a0
la $a0, space
li $v0, 4
syscall                    # 输出一个空格
addi $t0, $t0, 1
j loop_out

loop_out_end:
li $v0, 10
syscall                    # 结束程序
```

这里使用了 `lw` 和 `sw` 指令，对内存进行读写操作。`lw` 和 `sw` 要求地址对齐到字（即地址必须为 4 的倍数），否则会产生异常。由于字符串的长度不确定，并且打印字符串（`$v0` 为 4）的 `syscall` 对 `$a0` 的值没有对齐要求，因此在一般情况下，会把字符串的声明放在最后。同学们可以尝试把 str 的声明挪到 array 声明的前面，如果运行程序时产生了异常，则可以尝试让 str 字符串增加或减少一些字符，直到内存指令不再出现异常。

### 在MIPS中使用二维数组

下面再以一个简单题目为例，说明在 MIPS 中如何使用二维数组。

题目内容：输入两个数 m*m* 和 n*n*（1 \leq m \leq 81≤*m*≤8，1 \leq n \leq 81≤*n*≤8），代表有一个 m*m* 行 n*n* 列的矩阵，接下来 m*n*m*∗*n* 行每行一个 int 范围内的整数，依次输入矩阵的元素，最后输出这个矩阵（每两个数字中间一个空格，行末可以有多余空格，最后可以有多余回车）

**文本代码**：

```
.data
matrix: .space  256             # int matrix[8][8]   8*8*4 字节
                                # matrix[0][0] 的地址为 0x00，matrix[0][1] 的地址为 0x04，……
                                # matrix[1][0] 的地址为 0x20，matrix[1][1] 的地址为 0x24，……
                                # ……
str_enter:  .asciiz "\n"
str_space:  .asciiz " "

# 这里使用了宏，%i 为存储当前行数的寄存器，%j 为存储当前列数的寄存器
# 把 (%i * 8 + %j) * 4 存入 %ans 寄存器中
.macro  getindex(%ans, %i, %j)
    sll %ans, %i, 3             # %ans = %i * 8
    add %ans, %ans, %j          # %ans = %ans + %j
    sll %ans, %ans, 2           # %ans = %ans * 4
.end_macro

.text
li  $v0, 5
syscall
move $s0, $v0                   # 行数
li  $v0, 5
syscall
move $s1, $v0                   # 列数
# 这里使用了循环嵌套
li  $t0, 0                      # $t0 是一个循环变量

in_i:                           # 这是外层循环
beq $t0, $s0, in_i_end
li  $t1, 0                      # $t1 是另一个循环变量
in_j:                           # 这是内层循环
beq $t1, $s1, in_j_end
li  $v0, 5
syscall                         # 注意一下下面几行，在 Execute 页面中 Basic 列变成了什么
getindex($t2, $t0, $t1)         # 这里使用了宏，就不用写那么多行来算 ($t0 * 8 + $t1) * 4 了
sw  $v0, matrix($t2)            # matrix[$t0][$t1] = $v0
addi $t1, $t1, 1
j   in_j
in_j_end:
addi $t0, $t0, 1
j   in_i
in_i_end:
# 这里使用了循环嵌套，和输入的时候同理
li  $t0, 0

out_i:
beq $t0, $s0, out_i_end
li  $t1, 0
out_j:
beq $t1, $s1, out_j_end
getindex($t2, $t0, $t1)
lw  $a0, matrix($t2)            # $a0 = matrix[$t0][$t1]
li  $v0, 1
syscall
la  $a0, str_space
li  $v0, 4
syscall                         # 输出一个空格
addi $t1, $t1, 1
j   out_j
out_j_end:
la  $a0, str_enter
li  $v0, 4
syscall                         # 输出一个回车
addi $t0, $t0, 1
j   out_i

out_i_end:
li  $v0, 10
syscall
```

注意这里使用了宏，使得程序代码更为简洁，同学们可以在 Execute 页面中比较 Basic 和 Source 这两列的不同。

除此之外，同学们可以在 MARS 编辑器中按 F1 快捷键，阅读 MARS 的帮助文档，也可以在写程序的时候阅读一下代码补全的提示信息，从中也可以找到指令集文档中没有说明的指令，阅读这些帮助文档对同学们编写汇编程序有较大的帮助。MIPS 教程中只介绍了有限的几个指令，更多教程中没有介绍的指令还等待同学们的探索。

### 求Fibonacci数的程序

下面给出的是求前 12 个 Fibonacci 数的汇编程序。后面将以此为例，进行程序解析。

**文本代码**：

```
.data
fibs: .space   48           # "array" of 12 words to contain fib values
size: .word  12             # size of "array"
space:.asciiz  " "          # space to insert between numbers
head: .asciiz  "The Fibonacci numbers are:\n"

.text
la   $t0, fibs              # load address of array
la   $t5, size              # load address of size variable
lw   $t5, 0($t5)            # load array size
li   $t2, 1                 # 1 is first and second Fib. number
sw   $t2, 0($t0)            # F[0] = 1
sw   $t2, 4($t0)            # F[1] = F[0] = 1
addi $t1, $t5, -2           # Counter for loop, will execute (size-2) times

loop:
lw   $t3, 0($t0)            # Get value from array F[n]
lw   $t4, 4($t0)            # Get value from array F[n+1]
add  $t2, $t3, $t4          # $t2 = F[n] + F[n+1]
sw   $t2, 8($t0)            # Store F[n+2] = F[n] + F[n+1] in array
addi $t0, $t0, 4            # increment address of Fib. number source
addi $t1, $t1, -1           # decrement loop counter
bgtz $t1, loop              # repeat if not finished yet.
la   $a0, fibs              # first argument for print (array)
add  $a1, $zero, $t5        # second argument for print (size)
jal  print                  # call print routine.
li   $v0, 10                # system call for exit
syscall                     # we are out of here.

print:
add  $t0, $zero, $a0        # starting address of array
add  $t1, $zero, $a1        # initialize loop counter to array size
la   $a0, head              # load address of print heading
li   $v0, 4                 # specify Print String service
syscall                     # print heading

out:
lw   $a0, 0($t0)            # load fibonacci number for syscall
li   $v0, 1                 # specify Print Integer service
syscall                     # print fibonacci number
la   $a0, space             # load address of spacer for syscall
li   $v0, 4                 # specify Print String service
syscall                     # output string
addi $t0, $t0, 4            # increment address
addi $t1, $t1, -1           # decrement loop counter
bgtz $t1, out               # repeat if not finished
jr   $ra                    # return
```

1~7 行：变量声明与分配(伪指令)

8~14 行：初始化与寄存器分配

16~28 行：循环计算并保存 Fibonacci 数

30~47 行：输出提示语句和 Fibonacci 数

### 变量声明与定义

这部分使用到的就是在 MIPS 架构指令集一节中初步接触到的伪指令，在该程序中这些伪指令主要用途是标识数据段和代码段的位置，并为声明的数据分配空间。

```
.data
fibs: .space   48           # "array" of 12 words to contain fib values
size: .word  12             # size of "array"
space:.asciiz  " "          # space to insert between numbers
head: .asciiz  "The Fibonacci numbers are:\n"

.text
```

在 MARS 中的 Help 文档 MIPS -> Directives 一栏，对所有的伪指令都做了简要的介绍，如果大家想要进一步了解各个伪指令的具体用法，请自行上网搜索。接下来仅具体介绍程序中出现的这几条伪指令。(格式中 [XXX] 请用对应的数据替换)

1） `.data`

格式：.data [address]

说明：

- 定义程序的数据段，初始地址为 address，若无 address 参数，初始地址为设置的默认地址。
- 需要用伪指令声明的程序变量需要紧跟着该指令。比如该程序中的 fibs, size, space, head 这四个变量。

\2) `.text`

格式：.text [address]

说明：

- 定义程序的代码段，初始地址为 address，若无 address 参数，初始地址为设置的默认地址。
- 该指令后面就是程序代码。
- 在 MARS 中如果前面没有使用 `.data` 伪指令，可以不使用 `.text` 直接编写程序代码，代码将放置在前面设置的代码段默认地址中，但如果前面使用了 `.data` 伪指令，务必在代码段开始前使用 `.text` 进行标注。

\3) `.space`

格式：[name]: .space [n]

说明：

- 申请 n 个字节未初始化的内存空间，类似于其他语言中的数组声明。
- 这段数据的初始地址保存在标签 `name` 中。
- name 的地址是由 `.data` 段的初始地址加上前面所申请的数据大小计算得出的。由于前面申请的空间大小不定，有可能会出现后来申请的空间没有字对齐的情况，从而在使用 `sw`,`lw` 一类指令时出现错误，所以在申请空间时尽可能让 n 为 4 的倍数，防止在数据存取过程中出现问题。
- 在本例中，事先申请了 48 个字节也就是 12 个字的内存空间，用来保存我们之后计算出来的 12 个 Fibonacci 数，地址标签为 fibs。

\4) `.word`

格式：[name]: .word [data1],[data2] ….

说明：

- 在内存数据段中以字为单位连续存储数据 data1, data2,… (也就是将 datax **写入对应的 1 个字的空间**，注意 .word 和 .space 的区别)
- 这段数据的**初始地址保存在标签 name 中**。计算方式与上面相同。
- 在本例中，**把需要计算的 Fibonacci 数的个数保存在了内存数据段，地址标签为 size。**

\5) `.asciiz`

格式：[name]: . asciiz “[content]”

说明：

- 以字节为单位**存储字符串**，末尾以 NULL 结尾。
- 这个字符串在内存数据区的初始地址保存在标签 name 中。
- 注意 `.asciiz` 与 `.ascii` 这两条伪指令的区别。
- `.asciiz` 由于是**按字节存储，可能会导致之后分配的空间首地址无法字对齐的情况发生**，请大家自行思考解决方法。
- 本例中，声明了两个字符串，一个是**输出时需要用到的空格符**，一个是**输出语句**，地址标签分别为 space 和 head。

写入 1~8 行后点击扳手图标，就可以看到数据段空间分配的结果了。

仔细观察右边的 labels 部分，可以发现我们申请的四段空间是从 0x00000000 也就是数据段的首地址紧挨着分配得到的。

![image-20220922234917881](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922234917881.png)

把内存查看栏的 Hexadecimal Values 选项去掉就可以看到 fib 段总共分配了 48 字节(蓝色)，全部用 0 填充，而 size 所对应的一个字的空间(黄色)写入了 12。剩下用红色框标注的部分是前面声明的字符串

![image-20220922235001974](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922235001974.png)

再把内存查看栏的 ASCII 勾选，可以查看其中的字符串部分。将内存中字符串的分布与 head 段声明的字符串做个对比，大家是否心中有一些疑惑，本来好好的字符串怎么变成了这副模样，联系计算机存储数据方式解释一下为什么会出现这种现象。这个例子也可以帮助大家更好地理解计算机储存数据的模式。

![image-20220922235022113](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220922235022113.png)

### 宏的使用

#### **什么时候要用到宏？**

在我们的汇编代码中，可能会出现很多需要停止程序运行的地方，我们可以使用如下代码：

```
li  $v0, 10
syscall
```

并把这段代码复制粘贴到许多地方。但是这样的代码多了，会导致代码过于冗长，复用性差，不利于阅读。

同学们在编写汇编程序时，尤其时有关矩阵的程序，可能会频繁地使用具有较高相似度的代码段，尤其是在通过行数和列数获取矩阵中的元素的时候，需要频繁地计算(行数 * 最大列数 + 列数) * 4这样的数，代码如下（假设矩阵的最大列数为 8，行数存在 `$t0` 中，列数存在 `$t1` 中，最终结果计算到 `$t2` 中）：

```
sll $t2, $t0, 3
add $t2, $t2, $t1
sll $t2, $t2, 2
```

在编写程序的时候，我们可能会把这一小段代码复制多次并粘贴到不同的地方，对于矩阵乘法而言可能还要改一下寄存器的编号，稍微一个不注意就会产生难以发现的 bug。因此，我们应当想办法杜绝这种问题的发生，提高代码的复用性。

宏 (macro) 就是用来解决这个问题的方案，我们可以使用宏来提高代码的复用性，让这种问题得以解决。

#### **宏的用法**

宏分为两种，不带参数的宏和带参数的宏。

不带参数的宏，定义的方式如下：

```
.macro macro_name
# 代码段
.end_macro
```

第一个例子适合用不带参数的宏解决，我们可以定义这样一个宏：

```
.macro done
li  $v0, 10
syscall
.end_macro
```

此时，在需要程序停止运行的地方，使用 done 语句，就可以让程序在那里退出。汇编器会把所有的 macro_name 语句替换成代码段；在第一个例子中，汇编器把所有的 done 语句替换成

```
li  $v0, 10
syscall
```

这样就实现了代码复用。

带参数的宏，定义的方式如下：

```
.macro macro_name(%parameter1, %parameter2, ...)
# 代码段
.end_macro
```

和不带参数的宏不同的是，带参数的宏在 macro_name 后面有若干个用括号括起来的形式参数，每两个形式参数中间用逗号隔开，参数名前面有一个百分号。

第二个例子适合用带参数的宏解决，我们可以定义这样一个宏：

```
.macro  getindex(%ans, %i, %j)
    sll %ans, %i, 3
    add %ans, %ans, %j
    sll %ans, %ans, 2
.end_macro
```

其中 %i 代表行数，%j 代表列数，%ans 就是计算出来的结果 ((\%i * 8 + \%j ) * 4)((%*i*∗8+%*j*)∗4)。使用 `getindex($t2, $t0, $t1)` 来调用这个宏，汇编器会用这段代码替换它，同时 %ans 被替换成 `$t2`，%i 被替换成 `$t0`，%j 被替换成 `$t1`，因此最终会被替换成

```
sll $t2, $t0, 3
add $t2, $t2, $t1
sll $t2, $t2, 2
```

在矩阵乘法中，只需要替换调用宏的语句，问题就会被轻松解决，同时代码的复用性得到了提高，代码也更容易被人读懂。

在汇编程序中，还有一种和C语言中 #define 类似的宏定义，一般用于常量的定义上，那就是 `.eqv`。`.eqv` 用法如下：

```
.eqv EQV_NAME string
```

汇编器会把所有 EQV_NAME 的地方替换成 string，这可以用来定义一些常量。

在 P8 中，可能需要用汇编语言对数码管进行一些控制，控制数码管显示数字，每一个数字都有自己的编码，因此可以用 `.eqv` 对这些编码进行定义，例如：

```
.eqv    TUBECHAR_0  0x7E
.eqv    TUBECHAR_1  0x30
.eqv    TUBECHAR_2  0x6D
```

使得代码更加清晰，并且避免了代码中出现各种意义不明的数字。 

### 分配寄存器

这部分对应着代码中的 8~14 行，主要是做一些初始化工作，并为寄存器分配功能。

```mips
la   $t0, fibs        # load address of array
la   $t5, size        # load address of size variable
lw   $t5, 0($t5)      # load array size
li   $t2, 1           # 1 is first and second Fib. number
sw   $t2, 0($t0)      # F[0] = 1
sw   $t2, 4($t0)      # F[1] = F[0] = 1
addi $t1, $t5, -2     # Counter for loop, will execute (size-2) times
```

至于 MIPS 汇编中常用的 32 个通用寄存器都有什么功能，大家可以另外查阅资料，这里就不一一例举。

- 前两行所使用的 `la` 指令是 Mars 在标准指令集基础上扩充的一条指令，用于获取**标签**所指向的地址。比如 `la $t0, fibs` 就将 fibs 这个标签对应的地址 0x00000000 存入了 `$t0` 寄存器，用于之后向里面存入 Fibonacci 数。
- `la $t5, size` 和 `lw $t5, 0($t5)` 两行使用 `$t5` 寄存器保存所需要计算的 Fibonacci 数的总个数。首先用 `la` 将 size 的地址载入 `$t5` 中，再用 `lw` 指令从内存中的 `$t5` 所保存的地址 (因为偏移量为 0) 开始读取一个字 (也就是 12) 写入 `$t5` 中。
- `li` 指令也是一条扩展指令，可以直接往寄存器中写入一个 32 位的**立即数**，在这里向 `$t2` 这个寄存器中写入了 1，也就是斐波拉契数列的前两个元素的值，11、12 行是把前两个已知的 Fibonacci 数存入到 fibs 数组空间中，也就是 `$t0` 寄存器中所保存的地址对应的空间。
- 最后一行是使用 `$t1` 寄存器保存剩余需要计算的 Fibonacci 数的个数，之后每计算出一个 Fibonacci 数，`$t1` 就会自减。当 `$t1` 减为 0 时，代表计算任务已经完成。

### 循环运算

这部分功能比较单一，就是循环计算出 Fibonacci 数并将其保存至 fibs 数组中，对应着 loop 标签下的 16~28 行。

```mips
loop:
lw   $t3, 0($t0)      # Get value from array F[n]
lw   $t4, 4($t0)      # Get value from array F[n+1]
add  $t2, $t3, $t4    # $t2 = F[n] + F[n+1]
sw   $t2, 8($t0)      # Store F[n+2] = F[n] + F[n+1] in array
addi $t0, $t0, 4      # increment address of Fib. number source
addi $t1, $t1, -1     # decrement loop counter
bgtz $t1, loop        # repeat if not finished yet.
la   $a0, fibs        # first argument for print (array)
add  $a1, $zero, $t5  # second argument for print (size)
jal  print            # call print routine.
li   $v0, 10          # system call for exit
syscall               # we are out of here.
```

- 前两个 `sw` 指令是从 fibs 数组中提取前两个 Fibonacci 数 F(n-1)*F*(*n*−1) 和 F(n-2)*F*(*n*−2)，`add $t2, $t3, $t4` 根据公式 F(n)=F(n-1)+F(n-2)*F*(*n*)=*F*(*n*−1)+*F*(*n*−2) 计算出新的 Fibonacci 数，然后通过 `sw $t2, 8($t0)` 存入到数组空间中 (注意这三条 `lw` 指令的偏移量，可以联想 C 语言中数组指针的用法)
- 接下来两行 `addi $t0, $t0, 4` 和 `addi $t1, $t1, -1` 是修改 `$t0` 和 `$t1` 的值用于下次循环计算。(对 `$t0` 的操作可以联想 C 语言中指针的自增操作)
- `bgtz` 指令的含义是当寄存器中的值大于 0 时跳转到标签所在的位置，也就是说当 $$t1>0 $也就是运算还没有结束时，每次运行到`bgtz` 指令都会跳转到 `loop` 标签处计算下个 Fibonacci 数。
- `jal print` 表示跳转到 `print` 处开始输出，并将下一行的地址保存在 `$ra` 寄存器中，使得在调用完成 print 函数后还可以返回到下一行执行结束程序的部分代码。
- 这里的最后两行是 MARS 中结束程序的标准流程，更多的 `syscall` 用法请自行阅读 MARS 帮助文档，下一小节将更详细地介绍系统调用的相关注意事项。

### 系统调用

本部分的功能就是输出提示语句和 12 个 Fibonacci 数，为了实现这些功能，这里使用了 MIPS 汇编中的**系统调用**。这些系统调用是专门用来实现输入 / 输出，文件读取和终止运行等功能的一些指令，在 Mars 的 Help 文档中同样有详尽的介绍与使用说明。

这些系统调用的模式大都相同，一般都是**为 `$a0` 和 `$v0` 寄存器赋值**，执行 **`syscall`** 指令，然后汇编器就会根据 `$v0` 寄存器中的值进行不同的操作。下面会对程序中出现的进行解析。

```mips
print:
add  $t0, $zero, $a0  # starting address of array
add  $t1, $zero, $a1  # initialize loop counter to array size
la   $a0, head        # load address of print heading
li   $v0, 4           # specify Print String service
syscall               # print heading

out:  
lw   $a0, 0($t0)      # load fibonacci number for syscall
li   $v0, 1           # specify Print Integer service
syscall               # print fibonacci number
la   $a0, space       # load address of spacer for syscall
li   $v0, 4           # specify Print String service
syscall               # output string
addi $t0, $t0, 4      # increment address
addi $t1, $t1, -1     # decrement loop counter
bgtz $t1, out         # repeat if not finished
jr   $ra              # return
```

1. 字符串输出 代码：

   ```mips
   la $a0, addr
   li $v0, 4
   syscall
   ```

   说明：

   - 首先把要输出的字符串在内存中的**首地址**赋给 **`$a0`** 寄存器，然后汇编器就会根据 `$a0` 中的地址将字符串输出。
   - 在内存中存储的字符串是以 **NULL('\0')** 作为结束符，输出时遇到这个结束符就会停止。

2. 整数输出

   代码：

   ```mips
   li $v0, 1
   syscall
   ```

   说明：

   - 这个系统调用的功能就是把 **`$a0`** 寄存器中的数据以**整数**的形式输出。

3. 结束程序

   格式：

   ```mips
   li $v0, 10
   syscall
   ```

   说明：

   - 结束程序

### **指令解析：**

- 前两个 `add` 指令表示从 `$a0`, `$a1` 计算出需要输出的数组的首地址和大小。

- `la $a0, head` 表示获取需要输出的提示信息字符串的首地址。

  ```mips
  la   $a0, head        # load address of print heading
  li   $v0, 4           # specify Print String service
  syscall               # print heading
  ```

  这三行使用字符串输出系统调用将字符串输出。

- `lw $a0, 0($t0)` 表示从内存中获取一个斐波拉契数，接下来的两行为使用系统调用将其输出。

- `mips la $a0, space # load address of spacer for syscall li $v0, 4 # specify Print String service syscall # output string`

  这三行表示输出一个空格字符。

- 接下来两行 `addi` 指令是为下次循环做准备，利用 `bgtz` 指令判断是否输出已经结束，如果没有结束跳回到 `out` 标签处进行下次输出。

- `jr $ra` 表示完成输出返回到原代码 27 行处结束程序，即

  ```mips
  li    $v0, 10
  syscall
  ```

## MIPS汇编程序设计

### 条件语句

汇编语言本身是十分灵活的，但是这种灵活性可能会造成理解和编写上的困难，而模式化可以降低理解上的难度也可以让大家编写汇编语言代码时更加得心应手。这里将以程序中两种极其普遍的语句——条件语句与循环语句为例，做简单分析。首先来看条件语句：

```mips
.text
li $t1, 100             #t1 = 100
li $t2, 200             #t2 = 200
slt $t3, $t1, $t2       #if(t1 < t2) t3 = 1 
beq $t3, $0, if_1_else
nop
#do something
j if_1_end              #jump to end
nop
if_1_else:
#do something else

if_1_end:
li $v0, 10
syscall
```

这里展示了一个最简单的 if/else 语句，这段代码实现的功能非常简单，就是判断 `$t1` 和 `$t2` 两个寄存器中所储存的值的大小。如果 `$t1 < $t2` 则 do something 否则 do something else。

这段代码的核心实际上在第 5 行，第 5 行判断是否跳转决定了到底是执行 do something 还是执行 do something else。如果判断条件 `$t1 < $t2` 为真，即 `t3 == 1`，则不会跳转，继续执行 do something ，否则 `t3==0`，会跳转到 if_1_else 继续执行 do something else, 从而实现了 `if($t1 < $t2) {do something} else {do something else}` 的功能

同学们可以进一步思考 if/else if/else 语句以及switch语句该如何编写？如果条件变得更加复杂又该如何编写？

### 循环语句

```mips
.text
li $t1, 100             #n = 100
li $t2, 0               #i

for_begin1:             #for (int i = 0; i < n; i++)
slt $t3, $t2, $t1       #{
beq $t3, $0, for_end1  
nop        
#do something
addi $t2, $t2, 1        #i++
j for_begin1
nop                     #}    

for_end1:
li $v0, 10
syscall
```

上面的代码给出了一个标准 C 语言中 for 循环语句的汇编语言写法。

- 2，3 行初始化了 n 和 i.
- 6 行判断 `i < n` 是否为真，如果为真则第 7 行的 `beq` 不会跳转，否则跳转到 15 行结束程序。
- 9 行可以替换为需要在循环体内执行的代码。
- 10 行自增循环变量。
- 11 行跳回 5 行进行判断。

同学们请在此基础上进行扩充，并结合上一小节条件语句的写法，尝试一下如何编写多重循环语句，以及 while 循环和 do while 循环，并比较这几个循环之间的区别。

接下来我们将开始学习编写较为复杂的汇编程序。

### 需求分析

为了帮助大家更快的掌握汇编语言编程，在这里我们将带着大家一起设计一个简单的排序程序：对输入的 n 个整数进行排序后输出。相信在大一学习 C 语言时，同学们都已经学习过了相关的算法和 C 语言程序编写方法。那么使用汇编语言后，程序的行数势必会变长，但其原理是完全相同的。

事实上，为了实现功能，我们有两种实现思路：

- 只要求最终程序结果相同
- 在程序运行结果相同的情况下，使用汇编语言满足 C 语言程序的结构，模仿 C 语言程序的控制流、数据结构等。

简单想一想，前一种实现方法的行数势必会比后一种实现方法的代码量要少。但长远来看，由于汇编语言具有高度的灵活性而结构性、抽象性较差，当我们试图修改或扩展程序功能时，其结果就是难以修改，并且也难以查错。同时，也为了能更加详细地讲解汇编语言程序设计，我们将采用第二种实现思路来进行编写。

**注意：**在本讲的代码中，考虑了延迟槽，也就是说执行每条跳转指令后（无论是否跳转）都会执行它的下一条指令。延时槽的知识在此并不重要，只是让大家先认识一下，在后面的学习中会作为重点内容出现。而在本部分的代码中，将不会真正用到延时槽（即所有延时槽中都为 `nop` 指令）。

接下来我们可以把对上述排序题的分析总结为编程思路：

1. 要有输入输出提示语句
2. 先输入整数的个数 n，再输入 n 个整数。
3. 能够读取 n 个整数输入，并保存在内存中。
4. 要对 n 个整数进行从小到大排序，这里采用选择排序法。
5. 将排序后的整数进行输出。

### 程序结构设计

为了方便理解，我们仿照C语言来对程序进行分解。按照功能模块来分，程序可以分为 6 个部分：数据定义、主函数、输入部分、输出部分、排序部分、寻找最小值部分。

注意，虽然这里使用了“函数”一词，但这只是为了便于理解，事实上并不需要写成一个完整的“函数”，只需能将不同的功能区分开，便于理解即可。

![image-20220923005521197](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220923005521197.png)

1. 首先，程序需要声明几个内存区域来存储数列、字符串、临时变量等。
2. 然后来到主函数，主函数依次调用输入函数、排序函数和输出函数。
3. 排序函数循环调用寻找最小值部分，传递给寻找最小值部分想要遍历的范围，而寻找最小值部分则返回一个最小值的地址，以供排序部分进行交换。
4. 最终，程序结束，完成功能。

 关于通用寄存器的使用，实际上是一种**约定**，为了方便程序员之间的沟通而制定的规则。

1. 对于 s 寄存器而言，被调用者需要保证寄存器中的值在调用前后不能发生改变——对应到实际操作中，如果你想要编写一个子函数，那么在这个子函数中使用的所有 s 寄存器，都必须要在函数的开头入栈，在函数的结尾出栈，以确保其值在这个函数被调用前后不会发生变化。
2. 对于 t 寄存器而言则刚好相反，你编写的子函数中用到 t 寄存器的地方无需做任何保存，随意使用即可——因为维护 t 寄存器是上层函数的任务。这也就是所谓的 “s 寄存器由被调用者维护，t 寄存器由调用者维护”。
3. 需要注意的是，这仅仅是一个约定而已。你当然可以不遵守这种规范，但代价就是程序的合作和维护将变得举步维艰。在同学们编写 mips 代码的时候，尤其是涉及到子函数的编写时，我们推荐严格按照 mips 的规范进行，确保一个函数在被调用前后，其中所用到的 s 寄存器的值不会被改变。

一个调用者（即父函数）并不能预知其将要调用的子函数（即被调用者）会使用到哪些 t 寄存器，但可能在调用时并不想失去自己正在使用的某个 t 寄存器中的数据。

在这种情况下，为了维持 t 寄存器中的数据，调用者有两种选择：一是将所有 t 寄存器中的数据移至 s 寄存器，函数调用结束之后再移回来；二是将自己希望保留的 t 寄存器压入栈中，函数调用结束之后再弹回来。

第一种方法看似简单，但实际上引入了很多潜在的问题，比如：s 寄存器用完了怎么办？怎么确保子函数一定不会破坏 s 寄存器中的数据？在自动生成汇编代码（如编译）的过程中，怎样确定哪些 s 寄存器是可以用来保存 t 寄存器中的数据的？

因此，采用第二种方法，是一个更优雅，也更规范的做法。在第二种方法里，不再需要去考虑寄存器之间如何倒腾，只需要借助 sp 指针，不停地用栈去存取自己需要的数据就可以了。这减少了程序员的心智负担，规范了函数调用的过程，也方便了编译器的实现。

总而言之，调用者维护 t 寄存器，被调用者维护 s 寄存器的意义，就在于让代码更易于模块化。在这种约定下，调用者不需要去考虑被调用者的具体细节，被调用者也不需要去考虑自己被调用的方式。这使得 mips 代码可以以函数为单位进行模块化开发。

### 数据声明与分配



### 控制流

- 用于产生复杂的程序逻辑，在高级语言中很常见

- 分支

  -if-else

  -switch

- 循环

  -for

  -do…while

  -while

  ### if 语句

```
.data
s1: .asciiz "$t1 is greater than $t2\n"
s2: .asciiz "$t1 is not greater than $t2\n"

.text
li $t1, 100
li $t2, 200

slt $t3, $t2, $t1
beq $t3, $zero, if_1_else
nop
la $a0, s1
li $v0, 4
syscall
j if_1_end
nop

if_1_else:
la $a0, s2
li $v0, 4
syscall

if_1_end:
li $v0, 10
syscall
```

for语句

```
# for(i=0;i<n;i++){
#	//statement
# }

.text

li $t1, 100 #use $t1 as n
li $t2, 0   #use $t2 as i
 for_1_begin:
 slt $t3, $t2, $t1
 beq $t3, $zero, for_1_end
 nop
 
 ###################
 #    statement    #
 ###################
 addi $t2, $t2, 1	#i++
 j for_1_begin
 nop
 for_1_end:
 
```



### 输入与输出

```
.text
input:
la $a0, massage_input_n
li $v0 4
syscall

li $v0, 5
syscall
move $t0, $v0

li $t1, 0
 for_1_begin:
 slt $t2, $t1, $t0
 beq $t2, $zero, for_1_end
 nop
 
la $t2, array
li $t3 4
mult $t3, $t1
mflo $t3
addu $t2, $t2, $t3	 #变量太多的话可以把他们存在栈里

la $a0, message_input_array
li $v0, 4
syscall

li $v0, 5
syscall

sw $v0, array($t2)

 addi $t1, $t1, 1	#i++
 j for_1_begin
 nop
 for_1_end:
 move $v0, $t0
 jr $ra
 nop
 
 output:
 move $t0, $a0
 la $a0, message_output_array
 li $v0, 4
 syscall
 
 
```



### 排序与子过程调用

### 函数调用

之所以单独把函数调用作为一个章节来讲，是因为函数调用比普通的程序流控制（分支，跳转，判断）更加复杂。它是各种简单的程序流控制语句的组合。除此之外，函数调用还有具有某些特定的规范，这就更加大了用汇编语言书写函数的难度。我们可以总结出函数的如下特性：

- 函数是一个**代码块**，可以由指定语句调用，并且在执行完毕后返回调用语句。
- 函数通过传参，可以实现代码的**复用**。
- 函数只能通过返回值等有限手段对函数外造成影响。
- 函数里依然可以**嵌套调用**函数。

 我们会在下面的章节逐步用汇编语言实现函数的特性。我们会提供需要翻译的 C 代码，并且给出示例汇编程序，并且在必要处提供经典错误的汇编代码，希望同学们可以在自己的电脑上运行并调试代码，达到学习和避免错误的目的。

#### 代码块

 我们要翻译的 C 程序：

```c
#include<stdio.h>

int sum(int a, int b)
{
    int tmp = a + b;
    return tmp;
}

int main()
{
    int a = 2;
    int b = 3;

    int ans = sum(a, b);

    printf("%d\n", ans);

    return 0;
}
```

 对于函数调用，可以看成在函数调用的这条语句，程序跳转到函数的内容处开始执行，执行完整个函数以后再跳转回到调用处向下执行。这个跳转过程可以用汇编中的跳转指令和标签实现，格式如下：

```mips
# function call
jal funtion_name


# function
function_name:
    <function-content>
    jr $ra
```

 为什么这里我们选择 `jal` 而非 `j` 呢？我们知道j指令可以直接跳转到 label 的位置，`jal` 与其相比多了一个将 \tt{PC+4}PC+4 写入 31 号寄存器的过程。这样做的最大的好处在于，当我们函数结束时，我们可以通过`jr` 函数跳转回调用函数的位置。就像我们在 C 语言中，函数运行完后，会返回到之前调用它的位置，并执行下一条指令。所以在函数调用时，我们往往会搭配使用 `jal` 和 `jr`。

 按照这种方法，我们可以得到我们的第一个翻译版本：

```mips
.macro end
    li  $v0, 10
    syscall
.end_macro

.text
main:
li      $s0, 2  # int a = 2;
li      $s1, 3  # int b = 3;

jal     sum     # function call

li      $v0, 1
move    $a0, $s2
syscall         # print ans

end

sum:
add     $s2, $s0, $s1 
jr $ra
```

这样的 19 - 21 行，才是真正的函数体，我们规定了入口和出口，这块代码，只有按照我们规定的方法才能进入和出去的。

#### 复用代码

 仅仅写好了代码块，并没有完全实现函数的功能。因为我们没有办法实现代码的复用，比如 C 程序：

```c
int sum(int a, int b)
{
    int tmp = a + b;
    return tmp;
}

int main()
{
    int a = 2;
    int b = 3;
    int c = 4;
    int d = 5;

    int sum1 = sum(a, b);
    printf("%d", sum1);
    sum2 = sum(c, d);
    printf("%d", sum2);
    return 0;
}
```

 按道理，这个是可以复用 `sum` 的代码的，这也是函数很重要的一个功能，但是我们原来的那个函数操作的是 `$s0, $s1, $s2`，显然没有办法操作其他寄存器，所以为了复用代码，就必须让一些特定寄存器作为“接收器”，对于不同的参数，都采用同一组寄存器来存储他们的值，也就是我们说的形参寄存器 `$a0, $a1, $a2, $a3`。同样的道理，对于返回值，也是需要指定特定的寄存器。

 根据这种思想，我们可以对这个代码进行翻译：

```mips
.macro end
    li      $v0, 10
    syscall
.end_macro

.macro printStr(%str)
    la      $a0, %str
    li      $v0, 4
    syscall
.end_macro

.data
space: .asciiz " "

.text
li      $s0, 2
li      $s1, 3
li      $s2, 4
li      $s3, 5

move    $a0, $s0 #传参
move    $a1, $s1
jal     sum
move    $s4, $v0 #获得返回值

li      $v0, 1
move    $a0, $s4
syscall

printStr(space)

move    $a0, $s2
move    $a1, $s3
jal     sum
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#传参过程
move    $t0, $a0
move    $t1, $a1
#函数过程
add     $v0, $t0, $t1
jr      $ra
```

 可以看到，这样就实现了代码的复用。另外，`$a0, $a1, $a2, $a3` 只是一种程序员的约定，用其他的寄存器或者存储入内存中，都是可以的。当需要传递的参数超过 4 个的时候，我们一般将多出的参数存入内存。在 MIPS 中，我们使用内存的一个主要方法就是利用栈，我们可以通过控制栈指针寄存器 `$sp`，完成对内存的访问。

#### 避免对外界造成影响

 那么这样是不是函数功能就完善了呢，我们说不是的，因为函数还有一个重要的功能是不对函数体外的变量造成不必要的影响，比如我们有这样一个 C 程序：

```c
int sum(int a, int b)
{
    int tmp = a + b;
    return tmp;
}

int main()
{
    int a = 2;
    int b = 3;
    int c = 4;
    int sum1 = sum(a, b);
    int sum2 = sum(sum1, c);
    printf("%d", sum2);
    return 0;
}
```

 这段代码如果翻译成汇编，有可能会造成错误，以下是错误代码：

```mips
.macro end
    li      $v0, 10
    syscall
.end_macro

.text
li      $s0, 2
li      $s1, 3
li      $t0, 4

move    $a0, $s0 #传参
move    $a1, $s1
jal     sum
move    $s4, $v0 #获得返回值

move    $a0, $s4
move    $a1, $t0
jal     sum
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#传参过程
move    $t0, $a0 #t0被修改了
move    $t1, $a1
#函数过程
add     $v0 $t0, $t1
jr      $ra
```

 输出的答案是7，而不是9，这是因为我们储存 `c` 的寄存器是 `$t0`，而 `$t0` 在 `sum` 函数中被修改了，因此造成了 bug 。所以我们需要保证函数不会对外部造成影响，方法就是应用栈。

 栈在这里的作用是保存和恢复函数使用的寄存器，函数应该计算返回值，但不应该产生其他的负面影响。

 那么其实有两种使用栈的位置，第一种是在调用函数前，这种被称为**调用者保存**（在这里就是在 `main` 里面出入栈）：

```mips
.macro end
    li      $v0, 10
    syscall
.end_macro

.text
li      $s0, 2
li      $s1, 3
li      $t0, 4

move    $a0, $s0 #传参
move    $a1, $s1
sw      $t0, 0($sp) #入栈
addi    $sp, $sp, -4
jal     sum
addi    $sp, $sp, 4 #出栈
lw      $t0, 0($sp) 
move    $s4, $v0 #获得返回值

move    $a0, $s4
move    $a1, $t0
sw      $t0, 0($sp) #入栈
addi    $sp, $sp, -4
jal     sum
addi    $sp, $sp, 4 #出栈
lw      $t0, 0($sp)
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#传参过程
move    $t0, $a0
move    $t1, $a1
#函数过程
add     $v0 $t0, $t1
jr      $ra
```

 另一种是**被调用者保存**（在 `sum` 里出入栈）：

```mips
.macro end
    li      $v0, 10
    syscall
.end_macro

.text
li      $s0, 2
li      $s1, 3
li      $t0, 4

move    $a0, $s0 #传参
move    $a1, $s1
jal     sum
move    $s4, $v0 #获得返回值

move    $a0, $s4
move    $a1, $t0
jal     sum
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#入栈过程
sw      $t0, 0($sp)
addi    $sp, $sp, -4
#传参过程
move    $t0, $a0
move    $t1, $a1
#函数过程
add     $v0 $t0, $t1
#出栈过程
addi    $sp, $sp, 4
lw      $t0, 0($sp)
#return
jr      $ra
```

 关于具体采取哪一种办法，其实是涉及对寄存器种类的划分的。同学们可以结合教材自行理解。

#### 嵌套函数调用

 现在我们考虑在函数中调用函数的情况：

```c
int sum(int a, int b)
{
    return a + b;
}
int cal(int a, int b)
{
    return a - sum(b, a);
}

int main()
{
    int a = 2;
    int b = 3;
    int ans = cal(2, 3);
    printf("%d", ans);
}
```

我们按原来的理解将其翻译为汇编，会得到错误代码：

```mips
.macro end
    li $v0, 10
    syscall
.end_macro

.text
li      $s0, 2
li      $s1, 3

move    $a0, $s0
move    $a1, $s1
jal     cal
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#传参过程
move    $t0, $a0
move    $t1, $a1
#函数过程
add     $v0, $t0, $t1
#return
jr      $ra

cal:
#传参过程
move    $t0, $a0
move    $t1, $a1
#调用sum的过程
move    $a0, $t1
move    $a1, $t0
jal     sum
move    $t2, $v0
#运算a-sum(b, a)
sub     $v0, $t0, $t2 
#return
jr      $ra
```

 这段代码会陷入死循环，是因为寄存器 `$ra` 中存在的值，在调用完 `sum` 以后因为 `jal` 的作用会变为指向第 38 行，然后第 42 行跳转的时候，就又会跳到38行，然后到了 42 行又跳回 38 行，如此循环，所以我们发现，一旦一个函数不是叶子函数（叶子函数内不会调用函数），就需要保存和恢复 `$ra`。所以有正确代码：

```mips
.macro end
    li $v0, 10
    syscall
.end_macro

.text
li      $s0, 2
li      $s1, 3

move    $a0, $s0
move    $a1, $s1
jal     cal
move    $s5, $v0

li      $v0, 1
move    $a0, $s5
syscall

end

sum:
#将 $t0 和 $t1 入栈
sw      $t0, 0($sp)
addi    $sp, $sp, -4
sw      $t1, 0($sp)
addi    $sp, $sp, -4
#传参过程
move    $t0, $a0
move    $t1, $a1
#函数过程
add     $v0 $t0, $t1
#将 $t0 和 $t1 出栈
addi    $sp, $sp, 4
lw      $t1, 0($sp) 
addi    $sp, $sp, 4
lw      $t0, 0($sp) 
#return
jr      $ra

cal:
#将 $ra 入栈
sw      $ra, 0($sp)
addi    $sp, $sp, -4
#传参过程
move    $t0, $a0
move    $t1, $a1
#调用 sum 的过程
move    $a0, $t1
move    $a1, $t0
jal     sum
move    $t2, $v0
#运算a-sum(b, a)
sub     $v0, $t0, $t2
#将ra出栈
addi    $sp, $sp, 4
lw      $ra, 0($sp) 
#return
jr      $ra
```

由此我们可以总结出，嵌套函数调用的重要意识就是“用栈保存跳转地址”。

#### 递归函数调用

 经过层层铺垫，我们终于来到了最后的部分，也就是递归函数的汇编翻译。其实递归函数的本质就是**一个在函数体内调用自身的嵌套函数**。它与其他函数相比，没有过大的差异，我们只需要牢记上面的函数的特性和实现方法，就可以很轻松的翻译成功。

 下面我们实现一个阶乘程序，这是 C 语言版本：

```c
#include <stdio.h>

int factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }
    else
    {
        return n * factorial(n - 1);
    }
}

int main()
{
    printf("%d\n", factorial(5));

    return 0;
}
```

 我们给出汇编版本：

```mips
.macro end
    li      $v0, 10
    syscall
.end_macro

.macro getInt(%des)
    li      $v0, 5
    syscall
    move    %des, $v0
.end_macro

.macro printInt(%src)
    move    $a0, %src
    li      $v0, 1
    syscall
.end_macro

.macro push(%src)
    sw      %src, 0($sp)
    subi    $sp, $sp, 4
.end_macro

.macro pop(%des)
    addi    $sp, $sp, 4
    lw      %des, 0($sp) 
.end_macro

.text
main:
    getInt($s0)

    move    $a0, $s0
    jal     factorial
    move    $s1, $v0

    printInt($s1)
    end

factorial:
    # 入栈
    push($ra)
    push($t0)
    # 传参
    move    $t0, $a0
    #函数过程
    bne     $t0, 1, else
    # 基准情况
    if:
        li      $v0, 1
        j       if_end  
    # 递归情况  
    else:
        subi    $t1, $t0, 1
        move    $a0, $t1
        jal     factorial
        mult    $t0, $v0
        mflo    $v0
    if_end:
    # 出栈
    pop($t0)
    pop($ra)
    # 返回
    jr      $ra
```

 这段代码不仅集成了上面所有的所有的函数特性，而且代码风格是更加成熟的，现在我们来分析这段程序：

 首先是定义里一些宏，这些宏的定义可以化简我们的代码结构，方便我们阅读代码，并且降低出现 bug 的概率：

```mips
# 程序结束
.macro end
    li      $v0, 10
    syscall
.end_macro

# 从标准输入处得到一个整型变量，并存储到 %des 寄存器中
.macro getInt(%des)
    li      $v0, 5
    syscall
    move    %des, $v0
.end_macro

# 向标准输出中写入一个数据，这个数据保存在 %src 寄存器中
.macro printInt(%src)
    move    $a0, %src
    li      $v0, 1
    syscall
.end_macro

# 将寄存器 %src 中的数据入栈
.macro push(%src)
    sw      %src, 0($sp)
    subi    $sp, $sp, 4
.end_macro

# 将栈顶数据出栈，并保存在 %des 寄存器中
.macro pop(%des)
    addi    $sp, $sp, 4
    lw      %des, 0($sp) 
.end_macro
```

 然后分析 `main` 函数，可以看出逻辑十分简单，只是用 `jal` 的方式调用了 `factorial` 函数。这里也可以看出，对于调用者来说，递归函数的调用与非递归函数的调用并无差别。

```mips
main:
    getInt($s0)

    move    $a0, $s0
    jal     factorial
    move    $s1, $v0

    printInt($s1)
    end
```

 最后分析我们的重头戏，递归函数 `factorial`。

 因为 `factorial` 是一个递归函数，也就是说，他需要在内部调用函数，所以他不是一个叶子函数，所以需要将 `$ra` 入栈，此外，我们在函数中使用到了 `$t0` 寄存器，也是需要保存的，我们来看函数的传参和出入栈部分，写法十分的普世（对于每个函数，入口和出口都是十分固定的，都是入栈，传参，出栈，返回这四个基本流程）：

```mips
factorial:
    # 入栈
    push($ra)
    push($t0)
    # 传参
    move    $t0, $a0
    #函数过程
        ...
    # 出栈
    pop($t0)
    pop($ra)
    # 返回
    jr      $ra
```

 然后我们来分析函数的主体：

```mips
#函数过程
    bne     $t0, 1, else
    # 基准情况
    if:
        li      $v0, 1
        j       if_end  
    # 递归情况  
    else:
        subi    $t1, $t0, 1
        move    $a0, $t1
        jal     factorial
        mult    $t0, $v0
        mflo    $v0
    if_end:
```

 从 C 代码可以看出，这个函数是一个大的分支语句，我们首先判断输入的参数是否是 1（此时参数已经从 `$a0` 处拷贝到 `$t0` 处），如果是 1，那么就是基准情况，我们将返回值（`$v0`）设置为 1 以后就结束分支了。如果输入的参数不是 1，那么就需要递归调用，我们首先获得新的参数，就是将原来的参数减 1。然后再次调用 `factorial`。

 就像 C 一样，我们在结束了 11 行的语句后，认为此时返回值 `$v0` 中已经存储着我们想要的答案，我们做一个乘法，然后将结果存储在 `$v0` 中，返回即可。

 请你思考，为什么我们可以这样认为“此时返回值 `$v0` 中已经存储着我们想要的答案”。必要时可以自己画图理解。

## 测试程序设计

### 测试程序设计

#### 程序设计要点

- 首先，要明确 CPU 支持哪些指令，在 P7 之前，我们的测试程序中使用到的指令不能超出 **CPU 支持的范围**。
- 对于测试程序而言，我们追求的并不是过程与结果有多么巧妙，而是**全面**的测试每条指令。**比如测试加法，我们就要把正正相加，负负相加，正负相加的情况都考虑到。**
- 在用 Mars 编写测试程序时，对于一些伪指或看起来合法（但其实不合法，比如立即数溢出）的指令，Mars 会自动将其拆解转换成若干条基本指令，这样就违背了设计的初衷，如下图。将代码导入到 CPU 中进行测试之前，一定要注意这个问题。

#### **测试样例**

假设我们已经设计好了一个 CPU，它支持 `ori`, `lui`, `addu`, `sw`, `lw`, `beq` 这些指令，现在我们要写个测试程序来测试我们 CPU 的正确性(**暂不考虑延迟槽**)。

##### **从哪条指令开始呢**

构造测试程序的第一步是测试**最基本**的指令，只有最基本的指令正确了，我们才可以测试更复杂的指令。这些最基本的指令往往不依赖其它指令就可以判断其正确性，如 `ori`、`lui` 等。

接下来我们将先测试 `ori` 和 `lui` 指令，其它指令则需要靠这两条指令为寄存器赋值以进行测试，否则寄存器的值都是 0，难以有效的测试。

##### **ori 指令**

```mips
ori $a0, $0, 123
ori $a1, $a0, 456
# ori $a2, $0, -456
```

第一条我们先测最基本的与 0 进行或运算，第二条再测试两个非 0 数之间的或运算。从指令集的解释中，我们知道，`ori` 指令的第三个立即数参数是无符号扩展，所以不存在负数的情况。

##### **lui 指令**

```mips
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
```

根据指令集对 `lui` 的介绍，其实我们只测试第一条指令即可，后面两条指令是为了使用 `lui` 和 `ori` 指令**构造一个负数**，用于接下来 `addu` 指令的测试。

##### **addu 指令**

```mips
addu $s0, $a0, $a2      # 正正
addu $s1, $a0, $a3      # 正负
addu $s2, $a3, $a3      # 负负
```

对于 `addu` 指令，我们利用之前 `ori` 和 `lui` 准备好的寄存器进行三种情况的测试。

##### **sw 指令**

```mips
ori $t0, $0, 0x0000
sw $a0, 0($t0)
sw $a1, 4($t0)
sw $a2, 8($t0)
sw $a3, 12($t0)
sw $s0, 16($t0)
sw $s1, 20($t0)
sw $s2, 24($t0)
```

对于 `sw` 和 `lw` 指令，我们需要先测试 `sw` 往内存中存数据，这样才能通过 `lw` 取数据，否则内存中数据都是 0，难以判断 `lw` 指令实现的正确性。

##### **lw 指令**

```mips
lw $a0, 0($t0)
lw $a1, 12($t0)
sw $a0, 28($t0)
sw $a1, 32($t0)
```

这里我们利用之前 `sw` 存入内存的数据进行测试，最后再将结果重新存入内存。

##### **beq 指令**

```mips
ori $a0, $0, 1
ori $a1, $0, 2
ori $a2, $0, 1

beq $a0, $a1, loop1     # 不相等
beq $a0, $a2, loop2     # 相等

loop1:sw $a0, 36($t0)
loop2:sw $a1, 40($t0)
```

这里分别测试了条件成立与不成立的情况，如果 `beq` 在条件判断上实现有误，我们可以通过内存中的结果发现错误。

#### **完成测试样例**

```mips
ori $a0, $0, 123
ori $a1, $a0, 456
lui $a2, 123            # 符号位为 0
lui $a3, 0xffff         # 符号位为 1
ori $a3, $a3, 0xffff    # $a3 = -1
addu $s0, $a0, $a2      # 正正
addu $s1, $a0, $a3      # 正负
addu $s2, $a3, $a3      # 负负
ori $t0, $0, 0x0000
sw $a0, 0($t0)
sw $a1, 4($t0)
sw $a2, 8($t0)
sw $a3, 12($t0)
sw $s0, 16($t0)
sw $s1, 20($t0)
sw $s2, 24($t0)
lw $a0, 0($t0)
lw $a1, 12($t0)
sw $a0, 28($t0)
sw $a1, 32($t0)
ori $a0, $0, 1
ori $a1, $0, 2
ori $a2, $0, 1
beq $a0, $a1, loop1     # 不相等
beq $a0, $a2, loop2     # 相等
loop1:sw $a0, 36($t0)
loop2:sw $a1, 40($t0)
```

#### **结果测试**

在我们的程序中，已经把所有有用的数据都存入到了内存中（地址从 0 到 40）。所以只要将汇编程序对应的二进制代码导入 CPU 中，运行之后查看其内存中的数据，和 Mars 运行结果比较，就可以看出程序有没有错。

### 测试程序的使用

#### **说明**

本讲将会介绍如何在 **Logisim 搭建的 CPU 电路**和**使用 Verilog 语言编写的 CPU 工程文件**中使用测试程序验证 CPU 的正确性。

#### **Logisim 搭建的 CPU 电路**

1.准备测试程序

- 使用 Mars 编写测试程序，以 16 进制格式导出。
- 在导出的 .txt 文件的首行加上 `v2.0 raw`。
- 文件样例

> ```
> v2.0 raw
> 3c080001
> 35082f6a
> 34040004
> 34050001
> 34060004
> 34070020
> ac070000
> 8c0a0000
> ac880000
> 010a4823
> 00862021
> ac850000
> 00862021
> 00a52821
> ac850000
> 00862021
> 00a52821
> ac850000
> 00862021
> 00a52821
> ac850000
> 00862021
> 00a52821
> ac850000
> 00862021
> 00a52821
> ac850000
> 10e5fff0
> ```

2.导入到 IFU 模块中的 ROM 中

- IFU 模块中的 ROM 其实就是 IM，用来存储 CPU 将要执行的指令的集合。

- 导入步骤：

  (1) 选中 ROM 元件，右键 -> Edit Contents

![image-20220925141336629](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220925141336629.png)

(2) 在弹出的编辑框中点击 Open 导入我们准备好的测试程序。

![image-20220925141414201](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220925141414201.png)

3.运行 CPU 电路

- 选择菜单栏 Simulate -> Ticks Enabled 运行 CPU 电路。

4.检查结果

- 检查 GPR 模块中各个寄存器的值是否与预期的相同。
- 检查 DM 模块中内存数据的值是否与预期的相同。
- 测试程序预期的结果可以使用 Mars 查看。

#### **Verilog 语言编写的 CPU 工程文件**

1.准备测试程序

- Verilog 编写的 CPU 程序可直接使用 Mars 导出的 16 进制机器码文件，不需要额外的修改。

2.导入到 IM 中

- 在前期，我们是使用 reg 数组来模拟 ROM 存储指令的，比如 **`reg [31:0] im[1023:0]`** 就是一个可以存储 1024 条指令的 reg 数组，每个数组元素是 32 位，也就是一条指令的大小，数组下标是 0~1023。

- 我们向数组中存储数据时使用的是系统函数 `$readmemh`。

  (1) 格式：`$readmemh(“file”, mem_name, start_addr, stop_addr)`。

  (2) file 是导入的 16 进制测试文件，不使用绝对路径时要将其放在工程文件下。

  (3) mem_name 是我们存储元件的名字，这里就是数组的名字 im。

  (4) start_addr 和 stop_addr 是测试文件导入到存储元件中的起始地址和终止地址，在这里就是数组的下标，是可选参数。

- 样例：`$readmemh("code.txt", im);`

  (1) code.txt 是测试文件，im 是 reg 数组名。

  (2) 因为 im 数组大小为 4KB，所以提取指令时只需要用到 32 位地址中的前 12 位。相对于我们设置的起始地址 0x0000_3000 而言，前 12 位都是 0，所以指令正好是从数组的首个元素开始存储。因此，这里就不用地址参数了。

3.运行 CPU 程序

- 选中工程文件 -> Simulata Behavioral Modul

4.检查结果

- 在 Isim 界面左侧选择 Memory 选项，即可选择查看 GPR、DM、IM 中的数据。

![image-20220925141535127](C:\Users\W\AppData\Roaming\Typora\typora-user-images\image-20220925141535127.png)